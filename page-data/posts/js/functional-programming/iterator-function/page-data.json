{"componentChunkName":"component---src-templates-post-template-tsx","path":"/posts/js/functional-programming/iterator-function/","result":{"data":{"posts":{"edges":[{"node":{"id":"ddcb5561-8c83-5451-b61f-03fcfadff802","html":"<h2>다형성(polymorphism)이란?</h2>\n<p>프로그램 언어의 다형성은 그 프로그래밍 언어의 자료형 체계의 성질을 나타내는 것으로, 프로그램 언어의 각 요소들(상수, 변수, 식, 오브젝트, 함수, 메서드 등)이 다양한 자료형(type)에 속하는 것이 허가되는 성질을 가리킨다. 반대말은 단형성으로, 프로그램 언어의 각 요소가 한 가지 형태만 가지는 성질을 가리킨다. <code>위키피디아</code></p>\n<h3>내장함수의 다형성</h3>\n<p>다형성이란 하나의 메서드를 여러 개의 객체에 사용할 수 있는 것을 말합니다. javascript의 Array.property인 map을 예로 들어보겠습니다.</p>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\" theme=\"seti\"  >\n          <code slot=\"code\">const arr = [1, 2, 3, 4, 5];\nconsole.log(arr.map(v =&gt; v)); // [1, 2, 3, 4, 5];\n\nconst dom = document.querySelectorAll(&quot;*&quot;);\nconsole.log(dom.map(el =&gt; el.nodeName)); // TypeError!</code>\n        </deckgo-highlight-code>\n<p>배열에서는 map 함수가 잘 작동하지만, querySelectorAll로 반환된 배열에는 오류가 발생했습니다. document.querySelectorAll로 반환되는 객체는 배열처럼 보이지만 내부에는 map 함수가 존재하지 않습니다. 따라서 map 함수가 작동되지 않는 것입니다. 그렇기 때문에 유사한 배열의 유형에서도 작동할 수 있는 다형성이 높은 map함수를 직접 구성해보겠습니다.</p>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\" theme=\"seti\"  >\n          <code slot=\"code\">const map = (f, iter) =&gt; {\n  let res = [];\n  for (const a of iter) {\n    res.push(f(a));\n  }\n  return res;\n};\n\nconst dom = document.querySelectorAll(&quot;*&quot;);\nconsole.log(map(el =&gt; el.nodeName, dom)); // [&quot;HTML&quot;, &quot;HEAD&quot;, &quot;BODY&quot;]</code>\n        </deckgo-highlight-code>\n<p>map함수처럼 이터레이터를 이용하여 filter와 reduce도 재작성해보겠습니다.</p>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\" theme=\"seti\"  >\n          <code slot=\"code\">const filter = (f, iter) =&gt; {\n  let res = [];\n  for (const a of iter) {\n    if (f(a)) res.push(a);\n  }\n  return res;\n};\n\nconst reduce = (f, acc, iter) =&gt; {\n  if (!iter) { // iter 입력되지 않은 경우 초기값을 설정합니다.\n    iter = acc[Symbol.iterator](); // Symbol.iterator 호출\n    acc = iter.next().value;\n  }\n  for (const a of iter) {\n    acc = f(acc, a);\n  }\n  return acc;</code>\n        </deckgo-highlight-code>\n<h3>여러 메서드를 중첩으로 사용하기</h3>\n<p>자바스크립트에서 제공하는 기본 함수처럼 직접 만든 map, filter, reduce 함수도 연속으로 작성할 수 있습니다.</p>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\" theme=\"seti\"  >\n          <code slot=\"code\">const arr = [1, 2, 3, 4, 5];\narr\n  .map(v =&gt; v)\n  .filter(v =&gt; v &gt; 3)\n  .reduce((acc, cur) =&gt; acc + cur); // 9\n\nreduce(\n  (acc, cur) =&gt; acc + cur,\n  map(\n    v =&gt; v,\n    filter(v =&gt; v &gt; 3, arr)\n  )\n); // 9</code>\n        </deckgo-highlight-code>\n<p>위의 코드처럼 작성한다면 직접 작성한 함수들도 중첩하여 사용할 수 있습니다. 하지만 메서드체이닝 기능을 활용한 내장 함수와는 다르게 직접 구현한 함수는 중첩하여 사용하기 때문에 가독성이 떨어지는 문제가 있습니다. 이 부분을 조금 더 보기 좋도록 작성해 보겠습니다.</p>\n<h3>함수를 연속으로 실행하는 go함수</h3>\n<p>매개변수를 받아 reduce를 실행하는 함수를 작성합니다. go함수는 매개변수를 받아 reduce에게 전달합니다. reduce는 전달받은 매개변수를 가지고 함수를 진행하게 됩니다. 이처럼 다음과 같이 작성한다면 보다 보기 좋은 코드를 작성할 수 있습니다.</p>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\" theme=\"seti\"  >\n          <code slot=\"code\">const go = (...args) =&gt; reduec((a, f) =&gt; f(a), args);\ngo(\n  arr, // reduce의 초기값\n  arr =&gt; map(v =&gt; v, arr), // reduce에서 실행할 함수\n  arr =&gt; filter(v =&gt; v &gt; 3, arr),\n  arr =&gt; reduce((acc, cur) =&gt; acc + cur, arr)\n); // 9</code>\n        </deckgo-highlight-code>\n<h3>함수를 리턴하는 pipe함수</h3>\n<p>go함수를 이용하여 또 다른 함수를 작성해보겠습니다. pipe함수는 함수를 리턴하는 함수입니다. go를 이용하여 함수를 미리 정의해놓은 상태에서 값만 전달하여 원하는 결과를 얻어낼 수 있습니다.</p>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\" theme=\"seti\"  >\n          <code slot=\"code\">const pipe = (f, ...fs) =&gt; (...as) =&gt; go(f(...as), ...fs);\npipe(\n  arr =&gt; map(v =&gt; v, arr),\n  arr =&gt; filter(v =&gt; v &gt; 3, arr),\n  arr =&gt; reduce((acc, cur) =&gt; acc + cur, arr)\n);\npipe(arr);</code>\n        </deckgo-highlight-code>\n<h3>함수를 리턴하는 curry함수</h3>\n<p>함수를 리턴하는 방식으로 curry함수를 작성해보겠습니다. curry함수는 함수를 리턴하는 함수이며, 매개변수를 하나만 받는다면 또다시 리턴하여 매개변수를 하나 더 받는 함수입니다.</p>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\" theme=\"seti\"  >\n          <code slot=\"code\">const curry = f =&gt; (a, ..._) =&gt; (_.length ? f(a, ..._) : (..._) =&gt; f(a, ..._));\n\nconst mult = curry((a, b) =&gt; a * b);\nmult(3)(5); // 매개변수를 두번 나누어 요청할 수 있다.</code>\n        </deckgo-highlight-code>\n<p>매개변수의 개수를 체크하여 더 받는다는 것이 왜?라는 의문이 생길 수 있지만, 여기에서 기존에 작성하였던 map, filter, reduce함수에 curry함수를 적용한다면 조금 더 편하게 go함수를 사용할 수 있습니다.</p>\n<h3>curry가 적용된 map, filter, reduce 함수</h3>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\" theme=\"seti\"  >\n          <code slot=\"code\">const map = curry((f, iter) =&gt; {\n  let res = [];\n  for (const a of iter) {\n    res.push(f(a));\n  }\n  return res;\n});\n\nconst filter = curry((f, iter) =&gt; {\n  let res = [];\n  for (const a of iter) {\n    if (f(a)) res.push(a);\n  }\n  return res;\n});\n\nconst reduce = curry((f, acc, iter) =&gt; {\n  if (!iter) {\n    iter = acc[Symbol.iterator]();\n    acc = iter.next().value;\n  }\n  for (const a of iter) {\n    acc = f(acc, a);\n  }\n  return acc;\n});</code>\n        </deckgo-highlight-code>\n<deckgo-highlight-code language=\"jsx\" terminal=\"carbon\" theme=\"seti\"  >\n          <code slot=\"code\">go(\n  arr, // 초기값\n  map(v =&gt; v), // arr =&gt; map(v =&gt; v)(arr)으로 사용할 수 있기 때문에 arr을 생략가능.\n  filter(v =&gt; v &gt; 3),\n  reduce((acc, cur) =&gt; acc + cur)\n);</code>\n        </deckgo-highlight-code>\n<h2>참고</h2>\n<ul>\n<li><a href=\"https://www.inflearn.com/course/functional-es6\" target=\"_blank\" rel=\"nofollow\">함수형 프로그래밍과 JavaScript ES6+</a></li>\n</ul>","timeToRead":3,"frontmatter":{"title":"✨️ 이터레이터를 이용한 높은 다형성을 가진 함수","date":"Sep 26, 2021","update":null,"tags":["javascript","functional"]}}}]}},"pageContext":{"slug":"/posts/js/functional-programming/iterator-function/"}},"staticQueryHashes":["196858978","3066419403","3159585216"]}