{"index":{"title":"Welcome to Digital Garden 🧠","links":[],"tags":[],"content":"Hey, I’m Kumas 🐻"},"notes/access-git-repository-with-token":{"title":"git 저장소 token으로 접근하기","links":[],"tags":["git"],"content":"git config --global url.&quot;https://${PRIVATE-ACCESS-TOKEN}:x-oauth-basic@github.com/${id}&quot;.insteadOf &quot;github.com/${id}&quot;"},"notes/add-user-by-aws-eks":{"title":"AWS EKS 사용자 추가","links":[],"tags":["aws","devops"],"content":"- k describe -n kube-system configmap/aws-auth\n- k edit -n kube-system configmap/aws-auth\n출처\n\ndocs.aws.amazon.com/ko_kr/eks/latest/userguide/add-user-role.html\n"},"notes/call-flutter-tab-controller-event-twice":{"title":"Flutter tab controller 두번 호출되는 문제","links":[],"tags":["flutter"],"content":"이슈\n\ngithub.com/flutter/flutter/issues/13848\n\ntabController.indexIsChanging\n"},"notes/create-k8s-secret-storage":{"title":"k8s 시크릿 저장소 생성하기","links":[],"tags":["k8s"],"content":"k create secret generic ${secret} \\\n--from-literal=${key}=&quot;${value}}&quot;\n \n출처\n\nkubernetes.io/ko/docs/concepts/configuration/secret/\n"},"notes/delete-git-branch":{"title":"git 브랜치 삭제하기","links":[],"tags":["git"],"content":"git push origin --delete feature/branch"},"notes/difference-between-list-and-iterable-in-dart":{"title":"Dart에서 List와 Iterable의 차이점","links":[],"tags":["dart","cs"],"content":"List 선언시 생성됨\nIterable 사용시 생성됨\nvoid main(){\n  final numbers = List.generate(6, (index){\n    print(&#039;the number ${index + 1} generated&#039;);\n    return index + 1;\n  });\n \n \n  for(final number in numbers.take(2)){\n    print(&#039;the number $number is used&#039;);\n  }\n \n  print(&#039;---------------------------------------&#039;);\n \n  final values = Iterable.generate(6, (index){\n    print(&#039;The iterable number ${index + 1} generated&#039;);\n    return index + 1;\n  });\n \n  for(final number in values.take(2)){\n    print(&#039;Then iterable number $number is used&#039;);\n  }\n}\n \n// Output will look like this\n// the number 1 is generated\n// the number 2 is generated\n// the number 3 is generated\n// the number 4 is generated\n// the number 5 is generated\n// the number 6 is generated\n// the number 1 is used\n// the number 2 is used\n// ---------------------------------------\n// The iterable number 1 generated\n// The iterable number 1 is used\n// The iterable number 2 generated\n// The iterable number 2 is used\n// Output will look like this\n// the number 1 is generated\n// the number 2 is generated\n// the number 3 is generated\n// the number 4 is generated\n// the number 5 is generated\n// the number 6 is generated\n// the number 1 is used\n// the number 2 is used\n// ---------------------------------------\n// The iterable number 1 generated\n// The iterable number 1 is used\n// The iterable number 2 generated\n// The iterable number 2 is used\n \n참고\n\nmedium.com/@abdurrehman-520/lists-iterable-in-dart-72ccabfe045b\n"},"notes/difference-between-tar-and-tar-gz":{"title":"tar tar.gz 차이","links":[],"tags":["cli"],"content":"tar, tar.gz 차이\n압축되었나 되지 않았나 차이\ntar 파일 압축\ntar -cvf [압축파일명] [압축할 파일 혹은 폴더 경로]\ntar 압축 해제\ntar -xvf [압축파일명]\ntar.gz 파일 압축\ntar -cvf [압축파일명] [압축할 파일 혹은 폴더 경로]\ntar.gz 압축 해제\ntar -xvf [압축파일명]"},"notes/docker-ecr-login":{"title":"Docker ECR Login","links":["k8s-pod-내부에서-cURL-요청하기"],"tags":["docker","aws","devops"],"content":" aws ecr get-login-password --region ap-northeast-2 | docker login --username AWS --password-stdin 708660115569.dkr.ecr.ap-northeast-2.amazonaws.com/\ndocs.aws.amazon.com/ko_kr/AmazonECR/latest/userguide/docker-push-ecr-image.html\nk8s pod 내부에서 cURL 요청하기"},"notes/docker-login-by-aws-ecr":{"title":"AWS ECR docker 로그인","links":[],"tags":["aws","devops"],"content":"명령\naws ecr get-login-password --region region | docker login --username AWS --password-stdin aws_account_id.dkr.ecr.region.amazonaws.com\n참고\n프라이빗 레지스트리 인증"},"notes/fix-dorker-build-issue":{"title":"도커 빌드 이슈","links":[],"tags":["docker"],"content":"마지막 FROM에서 의존하고 있는 FROM만 실행하도록 변경. 아래의 코디에서는 마지막의 release을 실행하며, 의존하고 있는 build만 실행하는 문제 발생\nFROM node:16-alpine as build\n...\n \nFROM amazon/aws-cli:2.0.6 as s3_sync\n \nCOPY --from=build ...\n...\n \nFROM node:16-alpine as release\n \nCOPY --from=build ...\n...\n해결\ntarget을 지정하고 build를 두번하는 방식으로 해결\ndocker build --target release .\ndocker buiild --target s3_sync ."},"notes/index":{"title":"Notes","links":[],"tags":[],"content":""},"notes/install-k8s-cli":{"title":"k8s cli 설치","links":[],"tags":["k8s","cli"],"content":"brew install kubernetes-cli\naws.amazon.com/ko/premiumsupport/knowledge-center/eks-cluster-connection/"},"notes/install-nodebrew":{"title":"nodebrew 설치","links":[],"tags":["cli"],"content":"brew install nodebrew\nnodebrew setup\necho &quot;export PATH=$HOME/.nodebrew/current/bin:$PATH&quot; &gt;&gt;~/.zshrc"},"notes/install-ohmyzsh":{"title":"ohmyzsh 설치","links":[],"tags":["cli"],"content":"ohmyz.sh/#install\nsh -c &quot;$(curl -fsSL raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)&quot;"},"notes/openssl-cli":{"title":"openssl 명령어","links":[],"tags":["cli"],"content":"openssl ase-256-cbc -e ${KEY} -in ${FILE} -out ${FILE}\n-e 암호화\n-d 복호화"},"notes/python-hotreload":{"title":"python hotreload","links":[],"tags":["python"],"content":"python -m venv venv \nsource venv/bin/activate\npip install -e . \n``"},"notes/restore-git-branch":{"title":"git 삭제된 브랜치 복구","links":[],"tags":["git"],"content":"git reflog\n \n# git checkout -b &lt;생성할 브랜치명&gt; &lt;HEAD@{숫자}&gt;\ngit checkout -b &#039;dev&#039; HEAD@{1}\n출처\n\nshanepark.tistory.com/317\n"},"notes/set-icloud-custom-domain":{"title":"iCloud Custom Domain 설정","links":[],"tags":["etc"],"content":"iCloud Mail server settings for other email client apps\nUse these iCloud Mail server settings to manually set up your iCloud Mail account in an email client app.\nWith these iCloud Mail server settings, you can set up your email client app to send and receive email with your iCloud Mail account. You need these server settings when you manually configure your email client app.\nYou don’t need these mail server settings if you meet iCloud system requirements and can use any of these setup methods:\n\n\niCloud Mail uses the IMAP and SMTP standards supported by most modern email client apps. iCloud Mail does not support POP.\n\n\nIf you set up an account using iCloud System Preferences or macOS Mail in 10.7.4 or later, you won’t see these settings because they’re automatically configured.\n\n\nRefer to your email client app’s documentation for information about how to use these settings.\n\n\nServer name: imap.mail.me.com\n\n\nSSL Required: Yes\n\n\nIf you see an error message when using SSL, try using TLS instead.\n\n\nPort: 993\n\n\nUsername: This is usually the name of your iCloud Mail email address (for example, johnappleseed, not johnappleseed@icloud.com). If your email client app can’t connect to iCloud Mail using just the name of your email address, try using the full address.\n\n\nPassword: Generate an app-specific password.\n\n\nServer name: smtp.mail.me.com\n\n\nSSL Required: Yes\n\n\nIf you see an error message when using SSL, try using TLS or STARTTLS instead.\n\n\nPort: 587\n\n\nSMTP Authentication Required: Yes\n\n\nUsername: Your full iCloud Mail email address (for example, johnappleseed@icloud.com, not johnappleseed)\n\n\nPassword: Use the app-specific password that you generated when you set up the incoming mail server.\n\n\nInformation about products not manufactured by Apple, or independent websites not controlled or tested by Apple, is provided without recommendation or endorsement. Apple assumes no responsibility with regard to the selection, performance, or use of third-party websites or products. Apple makes no representations regarding third-party website accuracy or reliability. Contact the vendor for additional information.\niCloud Mail server settings for other email client apps"},"notes/slack-git":{"title":"slack git subscription 명령어","links":[],"tags":["cli"],"content":"/github subscribe black-tangerine/cocon-app-flutter reviews comments branches commits:*"},"notes/using-curl-inside-k8s":{"title":"k8s pod 내부에서 cURL 요청하기","links":[],"tags":["k8s"],"content":"kubectl run curl --image=radial/busyboxplus:curl --restart=Never -i --tty"},"notes/using-flutter-custom-clip":{"title":"Flutter CustomClip 사용법","links":[],"tags":["flutter"],"content":"자르고 싶은 형태를 SVG로 저장 후 아래의 링크에서 코드로 변환\nitchylabs.com/tools/path-to-bezier/\n \nclass CustomClip extends CustomClipper&lt;Path&gt; {\n  @override\n  Path getClip(Size size) {\n   ...\n  }\n \n  @override\n  bool shouldReclip(covariant CustomClipper&lt;Path&gt; oldClipper) {\n    throw UnimplementedError();\n  }\n}\nClipPath(\n\tclipper: clipper,\n\tchild: ...\n)"},"notes/using-flutter-dependency-in-git":{"title":"flutter git dependency 사용하기","links":[],"tags":["flutter"],"content":"# pubspec.yaml\n---\ndependency_overrides:\n  kakao_flutter_sdk_common:\n    git:\n      url: github.com/kakao/kakao_flutter_sdk.git\n      ref: develop\n      path: packages/kakao_flutter_sdk_common"},"notes/using-flutter-union-model":{"title":"Flutter Union Model 사용하기","links":[],"tags":["flutter"],"content":"@JsonSerializable()\nclass BannerDetailModel extends BannerModel {\n  const BannerDetailModel({\n\t\t...\n    required this.contents,\n  });\n \n  @_Converter()\n  final List&lt;Contents&gt; contents;\n\t...\n}\n \nclass _Converter implements JsonConverter&lt;Contents, Object&gt; {\n  const _Converter();\n \n  @override\n  Contents fromJson(Object json) {\n    if (json is Map&lt;String, dynamic&gt;) {\n      final type = json[&#039;type&#039;];\n      if (...) {\n        return ImageContents.fromJson(json);\n      }\n      if (...) {\n        return ProductContents.fromJson(json);\n      }\n    }\n \n    throw Exception();\n  }\n  ...\n}\n \nsealed class Contents {}\n \n@JsonSerializable()\nclass ImageContents implements Contents {\n  const ImageContents({\n\t...\n  });\n \n\t...\n  factory ImageContents.fromJson(Map&lt;String, dynamic&gt; json) =&gt;\n      _$ImageContentsFromJson(json);\n}\n \n@JsonSerializable()\nclass ProductContents implements Contents {\n  const ProductContents({\n\t...\n  });\n \n \n\t...\n  factory ProductContents.fromJson(Map&lt;String, dynamic&gt; json) =&gt;\n      _$ProductContentsFromJson(json);\n}\n "},"notes/validate-null-in-shell":{"title":"쉘 NULL 체크 하기","links":[],"tags":["shell"],"content":"#!/bin/sh\nTYPE=${1}\nif [ -z $TYPE ]\nthen\n  TYPE=TEST\nfi\necho ${TYPE}"},"posts/array-prototype":{"title":"JavaScript의 Array.Prototype","links":[],"tags":["javascript"],"content":"Array.prototype\n모든 Array 인스턴스는 Array.prototype으로부터 메서드와 프로퍼티를 상속받습니다. 이렇게 상속받은 Array.prototype 메서드는 크게 다음과 같이 구분할 수 있습니다.\n\n원본 배열을 변경하는 메서드\n원본 배열은 변경하지 않고 참조만 하는 메서드\n원본 배열을 반복적으로 참조하는 메서드\n\n원본 배열을 변경하는 메서드\n\npop\n\npop() 메서드는 배열에서 마지막 요소를 제거하고 그 요소를 반환합니다.\nlet arr = [1, 2, 3, 4, 5]\narr.pop() // 5\narr.pop() // 4\narr // [1, 2, 3]\n\npush\n\npush() 메서드는 배열의 끝에 하나 이상의 요소를 추가하고, 배열의 새로운 길이를 반환합니다.\nlet arr = [1, 2, 3, 4, 5]\narr.push(0) // 6\narr // [1, 2, 3, 4, 5, 0]\narr.push(6, 7) // 8\narr // [1, 2, 3, 4, 5, 0, 6, 7]\n\nshift\n\nshift() 메서드는 배열에서 첫 번째 요소를 제거하고, 제거된 요소를 반환합니다. 이 메서드는 배열의 길이를 변하게 합니다.\nlet arr = [1, 2, 3, 4, 5]\narr.shift() // 1\narr.shift() // 2\narr // [3, 4, 5]\n\nunshift\n\nunshift() 메서드는 새로운 요소를 배열의 맨 앞쪽에 추가하고, 새로운 길이를 반환합니다.\nlet arr = [1, 2, 3, 4, 5]\narr.unshift(0) // 6\narr // [0, 1, 2, 3, 4, 5, 0]\narr.unshift(6, 7) // 8\narr // [6, 7, 0, 1, 2, 3, 4, 5, 0]\n\nreverse\n\nreverse() 메서드는 배열의 순서를 반전합니다. 첫 번째 요소는 마지막 요소가 되며 마지막 요소는 첫 번째 요소가 됩니다.\nlet arr = [1, 2, 3, 4, 5]\narr.reverse() // [5, 4, 3, 2, 1]\n\nsort\n\nsort() 메서드는 배열의 요소를 적절한 위치에 정렬한 후 그 배열을 반환합니다. 기본 정렬 순서는 문자열의 유니코드 코드 포인트를 따릅니다\nlet strArr = [&quot;다&quot;, &quot;가&quot;, &quot;라&quot;, &quot;나&quot;]\nlet numArr = [10, 21, 1, 2, 3]\nstrArr.sort() // [&#039;가&#039;, &#039;나&#039;, &#039;다&#039;, &#039;라&#039;]\nnumArr.sort() // [1, 10, 2, 21, 3]\n \n// 직접 정렬의 방식을 지정해 줄 수도 있다.\nstrArr.sort(function (a, b) {\n  a.localeCompare(b)\n}) // [&#039;가&#039;, &#039;나&#039;, &#039;다&#039;, &#039;라&#039;]\n \nnumArr.sort((a, b) =&gt; {\n  return a - b\n}) // [1, 2, 3, 10, 21]\n \nlet items = [\n  { name: &quot;Edward&quot;, value: 21 },\n  { name: &quot;Sharpe&quot;, value: 37 },\n  { name: &quot;And&quot;, value: 45 },\n  { name: &quot;The&quot;, value: -12 },\n  { name: &quot;Magnetic&quot;, value: 13 },\n  { name: &quot;Zeros&quot;, value: 37 },\n]\n \nitems.sort(function (a, b) {\n  let nameA = a.name.toUpperCase()\n  let nameB = b.name.toUpperCase()\n  if (nameA &lt; nameB) {\n    return -1\n  }\n  if (nameA &gt; nameB) {\n    return 1\n  }\n  return 0\n})\n\nsplice\n\nsplice() 메서드는 배열의 기존 요소를 삭제 또는 교체하거나 새 요소를 추가하여 배열의 내용을 변경합니다.\nlet arr = [&quot;가&quot;, &quot;나&quot;, &quot;다&quot;, &quot;라&quot;, &quot;마&quot;]\n \narr.splice(1, 2, &quot;바&quot;, &quot;사&quot;) // [&#039;나&#039;, &#039;다&#039;]\narr // [&#039;가&#039;, &#039;바&#039;, &#039;사&#039;, &#039;라&#039;, &#039;마&#039;]\n원본 배열은 변경하지 않고 참조만 하는 메서드\n\njoin\n\njoin() 메서드는 배열의 모든 요소를 연결해 하나의 문자열로 만듭니다.\nconst arr = [1, 2, 3]\narr.join() // 1,2,3\narr.join(&quot; + &quot;) // 1 + 2 + 3\narr.join(&quot; &quot;) // 1 2 3\narr.join(&quot;&quot;) // 123\n\nslice\n\nslice() 메서드는 어떤 배열의 begin부터 end까지(end 미포함)에 대한 얕은 복사본을 새로운 배열 객체로 반환합니다.\nconst arr = [1, 2, 3, 4, 5]\narr.slice(1, 3) // [2, 3]\narr.slice(1) // [2, 3, 4, 5]\narr.slice(4, 5) // [5]\narr // [1, 2, 3, 4, 5]\n\nconcat\n\nconcat() 메서드는 해당 배열의 뒤에 인수로 전달받은 배열을 합쳐서 만든 새로운 배열을 반환합니다.\nconst arr = [1, 2]\nconst newArr = [3, 4]\narr.concat(newArr) // [1, 2, 3, 4]\narr.concat([5, 6]) // [1, 2, 5, 6]\narr.concat([7], [8, 9]) // [1, 2, 7, 8, 9]\n\nindexOf\n\nindexOf() 메서드는 배열에서 지정된 요소를 찾을 수 있는 첫 번째 인덱스를 반환하고 존재하지 않으면 -1을 반환합니다.\nconst arr = [&quot;가&quot;, &quot;나&quot;, &quot;다&quot;, &quot;라&quot;, &quot;가&quot;]\narr.indexOf(&quot;가&quot;) // 0\narr.indexOf(&quot;가&quot;, 1) // 4\narr.indexOf(&quot;나&quot;, 2) // -1\n\nincludes\n\nincludes() 메서드는 배열이 특정 요소를 포함하고 있는지 판별합니다.\nconst arr = [&quot;가&quot;, &quot;나&quot;, &quot;다&quot;, &quot;라&quot;, &quot;가&quot;]\narr.includes(&quot;가&quot;) // true\narr.includes(&quot;가&quot;, 1) // true\narr.includes(&quot;나&quot;, 2) // false\n원본 배열을 반복적으로 참조하는 메서드\n\nforEach\n\nforEach() 메서드는 주어진 함수를 배열 요소 각각에 대해 실행합니다.\nconst arr = [&quot;가&quot;, &quot;나&quot;, &quot;다&quot;]\narr.forEach((element) =&gt; {\n  console.log(element)\n})\n \n// 가\n// 나\n// 다\n\nmap\n\nmap() 메서드는 배열 내의 모든 요소 각각에 대하여 주어진 함수를 호출한 결과를 모아 새로운 배열을 반환합니다.\nconst arr = [1, 2, 3]\nconst newArr = arr.map((x) =&gt; {\n  return x * 2\n})\n \narr // 1, 2, 3\nnewArr // 2, 4, 6\n\nfilter\n\nfilter() 메서드는 주어진 함수의 테스트를 통과하는 모든 요소를 모아 새로운 배열로 반환합니다.\nconst arr = [1, 2, 3, 4, 5]\nconst result = arr.filter((x) =&gt; {\n  return x &gt; 2\n})\n \nresult // [3, 4, 5]\n\nreduce\n\nreduce() 메서드는 배열의 각 요소에 대해 주어진 리듀서(reducer) 함수를 실행하고, 하나의 결과값을 반환합니다.\nconst arr = [1, 2, 3, 4, 5]\nconst resultAdd = arr.reduce((acc, cur, i) =&gt; {\n  return acc + cur // 1 + 2 + 3 + 4 + 5\n}, 0)\n \nconst resultArry = arr.reduce((acc, cur, i) =&gt; {\n  acc.push(cur)\n  return acc // [1, 2, 3, 4, 5]\n}, [])\n참고\n\nMDN Web Docs\n"},"posts/async-function":{"title":"비동기 상황에서 잘 작동하는 함수","links":[],"tags":["javascript","functional-programming"],"content":"비동기 상황이란?\n비동기는 동시에 일어나지 않는다를 의미합니다.\n따라서 요청한 결과가 동시에 일어나지 않는다는 것입니다. 이전에 작성한 함수들을 비동기 상황에서도 잘 작동할 수 있도록 수정해 보겠습니다.\n비동기 작업을 처리하는 go1\n기존의 작성하였던 go함수에 비동기 상황이 발생하도록 코드를 만들어 보겠습니다.\ngo(\n  1,\n  (a) =&gt; a + 10,\n  (a) =&gt; Promise.resolve(a + 100),\n  (a) =&gt; a + 1000,\n  console.log,\n) // [object Promise]1000\n중간의 비동기 상황이 발생 시에 의도하지 않은 연산으로 결과 값이 전달됩니다. go, pipie 함수는 내부적으로 모두 reduce 함수를 사용하고 있기 때문에 reduce 함수를 수정해 보도록 하겠습니다.\ngo1을 적용한 reduce\n// fx.js\n \n// const reduce = curry((f, acc, iter) =&gt; {\n//   if (!iter) {\n//     iter = acc[Symbol.iterator]();\n//     acc = iter.next().value;\n//   }\n//   for (const a of iter) {\n//     acc = f(acc, a);\n//   }\n//   return acc;\n// });\n \nconst go1 = (a, f) =&gt; (a instanceof Promise ? a.then(f) : f(a))\n \nconst reduce = curry((f, acc, iter) =&gt; {\n  if (!iter) {\n    iter = acc[Symbol.iterator]()\n    acc = iter.next().value\n  } else {\n    iter = acc[Symbol.iterator]()\n  }\n \n  return go1(acc, function recur(acc) {\n    let cur\n    while (!(cur = iter.next()).done) {\n      const a = cur.value\n      acc = f(acc, a)\n      if (acc instanceof Promise) return acc.then(recur)\n    }\n    return acc\n  })\n})\ngo1이라는 메서드를 작성합니다. 이 메서드는 instanceof를 이용하여 전달받은 객체가 Promise인지 체크합니다. Promise라면 then한뒤 값을 전달하고 아니라면 이전과 동일하게 작동하도록 합니다.\n반복문으로 처리되던 부분을 유명 함수로 선언하여 반복하도록 합니다. 또한 for… of에서 while으로 바뀌었는데, for… of는 내부적으로 반복이 종료되는 경우에는 이터레이터의 리턴 메서드를 강제로 실행시켜버리기 때문에 while을 사용하여 반복문을 실행합니다.\ngo1을 적용한 L.map\ngo1함수를 이용하여 map함수도 비동기 상황의 코드를 작성해 보겠습니다.\ngo(\n  [Promise.resolve(1), Promise.resolve(2), Promise.resolve(3)],\n  L.map((a) =&gt; a + 10),\n  take(2),\n  console.log,\n) // [&quot;[object Promise]10&quot;, &quot;[object Promise]10&quot;]\n우리가 예상한 결과값은 11, 12가 나와야했엇지만 엉뚱한 값이 출력 되었습니다. 해당 연산이 정상적으로 나올수 있도록 함수를 수정해 보겠습니다.\n// fx.js\n \nL.map = curry(function* (f, iter) {\n  for (const a of iter) yield go1(a, f)\n})\n \ngo(\n  [Promise.resolve(1), Promise.resolve(2), Promise.resolve(3)],\n  L.map((a) =&gt; a + 10),\n  take(2),\n  console.log,\n) // [Promise, Promise]\nmap함수도 go1을 이용하여 비동기 상황에서도 정상적으로 연산이 되도록 수정하였습니다. 하지만 아직 Promise값을 출력하고 있습니다. 결괏값을 만들어 내는 take함수도 reduce함수처럼 수정해 보도록 하겠습니다.\n// fx.js\n \n// const take = curry((l, iter) =&gt; {\n//   let res = [];\n//   for (const a of iter) {\n//     res.push(a);\n//     if (res.length == l) return res;\n//   }\n//   return res;\n// });\nconst take = curry((l, iter) =&gt; {\n  let res = []\n  iter = iter[Symbol.iterator]()\n  return (function recur() {\n    let cur\n    while (!(cur = iter.next()).done) {\n      const a = cur.value\n      if (a instanceof Promise) {\n        return a.then((a) =&gt; {\n          res.push(a)\n          return res.length === l ? res : recur()\n        })\n      }\n      res.push(a)\n      if (res.length == l) return res\n    }\n    return res\n  })()\n})\nnop을 이용해 비동기 처리하는 L.filter\ngo(\n  [1, 2, 3, 4, 5],\n  L.map((a) =&gt; Promise.resolve(a * a)),\n  L.filter((a) =&gt; {\n    console.log(a) // Promise {&lt;resolved&gt;: 1} ...\n    return a % 2\n  }),\n  take(2),\n  console.log,\n) // []\n이번엔 filter까지 비동기 상황을 잘 처리할 수 있도록 변경해보겠습니다. 기존의 필터 함수는 비동기 상황을 처리 못하기 때문에 비정상적인 값을 출력하기 때문에 filter함수를 수정하여 비동기 상황을 정상적으로 처리할 수 있도록 수정해 보겠습니다.\n// fx.js\n \n// L.filter = curry(function* (f, iter) {\n//   for (const a of iter) {\n//     if (f(a)) yield a;\n//   }\n// });\n \nconst nop = Symbol(&#039;nop&#039;);\n \nL.filter = curry(function* (f, iter) {\n  for (const a of iter) {\n    const b = go1(a, f);\n    if (b instanceof Promise) yield b.then(b =&gt; b ? a : Promise.reject(nop));\n    else if (b) yield a;\n  }\n});\n \nconst take = curry((l, iter) =&gt; {\n  let res = [];\n  iter = iter[Symbol.iterator]();\n  return (function recur() {\n    let cur;\n    while (!(cur = iter.next()).done) {\n      const a = cur.value;\n      if (a instanceof Promise) {\n        return a\n          .then((a) =&gt; {\n            res.push(a);\n            return res.length === l ? res : recur();\n          })\n          .catch((e) =&gt; { // nop 처리를 위해 추가된 부분.\n            return e == nop ? recur() : Promise.reject(e);\n          });\n      }\n      res.push(a);\n      if (res.length == l) return res;\n    }\n    return res;\n  })();\n \n  go(\n  [1, 2, 3, 4, 5],\n  L.map(a =&gt; Promise.resolve(a * a)),\n  L.filter(a =&gt;  a % 2 ),\n  take(2),\n  console.log\n  ) // [1, 9]\n기존의 L.filter 함수는 이터레이터를 반복하며 함수 결괏값이 true인지 체크한 뒤 반환하도록 되어 있었습니다. 하지만 전달받은 함수가 Promise라면 정상적으로 연산되지 않기 때문에 go1 함수를 이용하여 연산합니다. 그 이후 연산된 값이 Promise 인지 체크하여 반환합니다.\n하지만 L.filter 함수의 특성상 조건에 맞지 않는 값은 전달하지 않아야 하는데, 그렇게 처리하기 위해 nop이라는 임의의 구분자를 생성합니다. nop 구분자는 L.filter에서 전달하지 않아야 하는 값이라면 Promise.reject을 반환하며 nop 구분자를 전달합니다. 그렇게 되면 결과적으로 Promise는 에러를 발생시키기 때문에 해당 값을 전달하지 않게 됩니다.\n그렇다면 take 함수에서 nop 구분자를 처리해 줄 수 있도록 수정합니다. 기존의 then함수에 catch 부분을 추가하여 해당 에러가 의도한 상황이면 다음 코드들을 평가하도록 recur() 함수를 호출하고 실제 에러가 발생했다면 다시 reject(e)을 통하여 에러를 발생시켜 줍니다.\nnop 지원하는 reduce\nreduce 함수도 take함수처럼 nop을 지원하도록 수정해 보겠습니다.\ngo(\n  [1, 2, 3, 4, 5],\n  L.map((a) =&gt; Promise.resolve(a * a)),\n  L.filter((a) =&gt; Promise.resolve(a % 2)),\n  reduce((a, b) =&gt; a + b),\n  console.log,\n) // 1[object Promise][object Promise][object Promise] Uncaugth (in promise) Symbol(nop)\n일단 이전의 수정한 reduce함수는 첫 번째 인자가 Promise인지만 체크해서 계산하기 때문에 해당 부분을 매번 Promise를 체크하여 풀어줄 수 있도록 수정하고 nop을 잘 처리할 수 있도록 수정해 보겠습니다.\n// fx.js\n \nconst reduceF = (acc, a, f) =&gt;\n  a instanceof Promise\n    ? a.then(\n        (a) =&gt; f(acc, a),\n        (e) =&gt; (e == nop ? acc : Promise.reject(e)),\n      )\n    : f(acc, a)\n \nconst reduce = curry((f, acc, iter) =&gt; {\n  if (!iter) {\n    iter = acc[Symbol.iterator]()\n    acc = iter.next().value\n  } else {\n    iter = acc[Symbol.iterator]()\n  }\n \n  return go1(acc, function recur(acc) {\n    let cur\n    while (!(cur = iter.next()).done) {\n      // const a = cur.value;\n      // acc = f(acc, a);\n      acc = reduceF(acc, cur.value, f)\n      if (acc instanceof Promise) return acc.then(recur)\n    }\n    return acc\n  })\n})\nreduceF라는 함수를 작성합니다. 전달받은 값이 Promise값인지 체크하여 then으로 연산하여 함수를 적용을 해주는 함수입니다. 또한 then을 처리하면서 catch를 통해 nop 구분자도 처리를 해줄 수 있도록 했습니다.\ngo(\n  [1, 2, 3, 4, 5],\n  L.map((a) =&gt; Promise.resolve(a * a)),\n  L.filter((a) =&gt; Promise.resolve(a % 2)),\n  reduce((a, b) =&gt; a + b),\n  console.log,\n) // 35\n이전의 작성한 코드를 새로 실행해 보면 정상적으로 잘 작동하는 것을 알 수 있습니다.\n참고\n\n함수형 프로그래밍과 JavaScript ES6+\n"},"posts/async-promise":{"title":"비동기를 값으로 다루는 Promise","links":[],"tags":["javascript"],"content":"Promise란?\nPromise 객체는 비동기 작업이 맞이할 미래의 완료 또는 실패와 그 결괏값을 나타냅니다. MDN\nES6에서 추가된 Promise는 비동기 연산을 하기 위한 객체이며 기존의 callback 함괏의 단점들을 보완한 함수입니다.\nPromise는 다음 중 하나의 상태를 가집니다.\n\n대기(pending): 이행하거나 거부되지 않은 상태\n이행(fulfilled): 연산이 성공적으로 완료됨.\n거부(rejected): 연산이 실패함.\n\nPromise의 사용방법\nPromise는 resolve, reject 두 인자를 매개변수로 받습니다. 이 두 함수는 promise를 이행하거나 거부합니다. 비동기 작업이 모두 끝난 뒤 resolve를 호출해서 이행하고, 오류가 생겼다면 reject를 이용하여 거부할 수 있습니다. 또한 Promise 객체에는 비동기 상태가 담겨있기 때문에 비동기 처리 시점을 명확하게 표시할 수 있습니다.\nconst promise = new Promise((resolve, reject) =&gt; {})\n \nconsole.log(promise) // Promise {status: &quot;pending&quot;}\nthen, catch, finally\nPromise가 종료되면 then과 catch로 resolve와 reject의 값을 꺼내어 볼 수 있습니다. 하지만 reject 된 경우에는 catch 항목이 없다면 오류가 발생합니다.\nconst promise1 = new Promise((resolve, reject) =&gt; {\n  setTimeout(() =&gt; resolve(&quot;성공&quot;), 1000)\n}) // 10초 후에 결과 출력\n \npromise1.then(console.log) // 성공\n \nconst promise2 = new Promise((resolve, reject) =&gt; {\n  setTimeout(() =&gt; reject(&quot;실패&quot;), 1000)\n}) // 10초 후에 결과 출력\n \npromise2.then(console.log) // 오류가 발생했지만 catch 항목이 없어서 error 발생\n// Uncaught (in promise) 실패\npromise2\n  .then(console.log)\n  .catch(console.error) // 실패\n  .finally(() =&gt; console.log(&quot;종료됨&quot;)) // 이행이나 거부와 상관없이 무조건 실행됨\n메서드 체이닝\nPromise의 리턴값은 자기 자신을 반환하기 때문에 함수를 연속적으로 사용할수 있습니다. 또한 연속적으로 사용한 함수에서 에러처리 또한 매번 할 필요 없이 한번만 처리 해주면 됩니다.\nconst promise = new Promise((resolve, reject) =&gt; resolve(1));\nconst add1 = (num) =&gt; num + 1;\n \npromise\n  .then(add1)\n  .then(add1) // 연속적으로 then 호출 가능\n  .then(console.log);\n  .catch(console.error); // 연속적으로 then을 호출하더라도 하나의 catch에서 처리\nPromise.all, Promise.rece\nPromise 메서드 종류\n\nPromise.all: 주어진 모든 Promise를 이행합니다.\nPromise.rece: 주어진 모든 Promise 중 가장 먼저 완료된 것만 이행합니다.\n\n// Promise.all\n \nconst promise1 = new Promise((resolve) =&gt; setTimeout(resolve, 3000, &quot;첫번째&quot;))\n \nconst promise2 = new Promise((resolve) =&gt; setTimeout(resolve, 2000, &quot;두번째&quot;))\n \nconst promise3 = new Promise((resolve) =&gt; setTimeout(resolve, 1000, &quot;세번째&quot;))\n \nconst allPromise = Promise.all([promise1, promise2, promise3])\nallPromise\n  .then(console.log) // 모든 promise를 이행한뒤 출력\n  .catch(console.error)\n// [ &#039;첫번째&#039;, &#039;두번째&#039;, &#039;세번째&#039;]\n// Promise.rece\n \nconst promise1 = new Promise((resolve, reject) =&gt; setTimeout(reject, 3000, &quot;첫번째&quot;))\n \nconst promise2 = new Promise((resolve) =&gt; setTimeout(resolve(&quot;두번째&quot;), 2000))\n \nconst promise3 = new Promise((resolve) =&gt; setTimeout(resolve(&quot;세번째&quot;), 1000))\n \nconst recePromise = Promise.race([promise1, promise2, promise3])\n \nrecePromise\n  .then(console.log) // 가장 먼저 끝난 세번째만 반환하고 종료\n  .catch(console.error) // 첫번째가 이행되지 않아서 오류발생안함\n// [ &#039;세번째&#039;]\n참고\n\n함수형 프로그래밍과 JavaScript ES6+\n"},"posts/baekjoon-init":{"title":"백준 문제풀이 세팅 (Node.js)","links":[],"tags":["algorithm","node"],"content":"개요\n프로그래머스와 LeetCode와는 다르게 백준에서의 알고리즘 문제 풀이는 입력까지 모두 사용자가 구현해야 합니다. JavaScript로 문제를 풀이할 것이기 때문에 Node 세팅을 해보겠습니다.\n설치\n아래의 형식과 같이 프로젝트를 생성해 줍니다.\n├── dev\n│   └── stdin\n└── index.js\n\n백준은 dev의 stdin파일에 입력 파일이 존재합니다. 해당 파일을 읽어와 코드를 실행할 수 있도록 해보겠습니다.\n// index.js\nlet fs = require(&quot;fs&quot;)\nlet input = fs.readFileSync(&quot;./dev/stdin&quot;).toString().trim().split(&quot; &quot;)\n \nlet a = parseInt(input[0])\nlet b = parseInt(input[1])\n \nconsole.log(a + b)\nfs모듈을 이용하여 파일을 읽어와 string 타입으로 변환하여 split을 이용하여 분리하는 방식입니다. 여러 줄을 입력을 받는다면 split(‘\\n’)을 이용하여 입력을 받을 수도 있습니다. 또한 구조 분해 할당을 이용한다면 아래와 같이도 사용할 수 있습니다.\n// index.js\nlet [n, ...arr] = require(&quot;fs&quot;).readFileSync(&quot;./dev/stdin&quot;).toString().trim().split(&quot;\\\\n&quot;) // 첫번째 입력 항목의 갯수, 두번째 입력항목인 경우\n \nconsole.log(n) // 첫번째 행의 값\nconsole.log(arr) // 나머지 행의 값의 배열\n참고\n\nBaekjoon Online Judge\n"},"posts/concurrency-function":{"title":"지연된 함수열을 병렬적으로 평가하기","links":[],"tags":["javascript","functional-programming"],"content":"자바스크립트는 비동기 IO 동작을 합니다. 이는 하나의 쓰레드에서 IO작업을 효율적으로 처리할 수 있도록 하기 위함입니다. 하지만 데이터베이스 같은 외부에 IO 작업을 요청하는 경우에는 그저 명령을 전달 후 완료 시점을 대기하는 상황이기 때문에 자바스크립트에서도 병렬적인 작업이 필요합니다.\n지연된 함수의 평가\n명령을 요청하면 1초가 소요되는 IO작업이 있다고 한다면, 해당 작업을 순차적으로 진행하며 go 함수를 진행할 것입니다.\nconst delay1000 = (a) =&gt; newPromise((resolve) =&gt; setTimeout(() =&gt; resolve(a), 1000)) // 1초가 필요한 비동기 작업\n \ngo(\n  [1, 2, 3, 4, 5],\n  L.map((a) =&gt; delay1000(a * a)),\n  L.filter((a) =&gt; a % 2),\n  reduce((a, b) =&gt; a + b),\n  console.log,\n)\n// 35\n// default: 5016.022216796875 ms\n지연된 함수를 병렬적으로 평가\nC.reduce를 작성하여 전달받은 iter를 전개 연산자로 전달하여 줍니다. iter가 생략된 경우에는 acc가 iter이기 때문에 이 부분을 처리하여 전달합니다. 그저 전개 연산자로 전달했을 뿐인데, 모든 작업이 병렬적으로 처리되었습니다.\nconst C = {};\nC.reduce = curry((f, acc, iter) =&gt; iter ? ruduce(f, acc, [...iter]): reduce(f, [...acc]))\nconst delay1000 = a =&gt; newPromise(resolve =&gt; setTimeout(() =&gt; resolve(a), 1000)) // 1초가 필요한 비동기 작업\n \ngo(\n  [1, 2, 3, 4, 5],\n  L.map(a =&gt; delay1000(a * a)),\n  L.filter(a =&gt; a % 2),\n  reduce((a, b) =&gt; a + b)\n  console.log\n)\n// 35\n// default: 1005.98291015625 ms\n… 전개연산자의 원리\n제너레이터 함수는 next()을 진행할 때마다 yield를 한 번씩 진행하지만, 전개 연산자로 iter을 호출할 경우 남아있는 yield를 한 번에 호출하는 것을 볼 수 있습니다.\nfunction* f() {\n  yield console.log(1)\n  yield console.log(2)\n  yield console.log(3)\n}\n \nconst iter = f() // 아무일도 일어나지 않음\niter.next() // 콘솔이 1 찍힘\n;[...iter] // 콘솔에 2, 3 찍힘\n병렬적 평가에서 nop 체크하기\nfilter 함수에서 비동기 작업의 경우 조건이 부합하지 않는 값은 Promise.reject을 통해 자연스럽게 흘려보내도록 설계하였습니다. 하지만 이때 임의로 만든 nop이라는 구분자로 실제 에러인지, 의도한 상황인지 구별하도록 하였습니다. 이 부분에서 reject에 대해 catch하지 않아 Uncaught 에러가 발생합니다.\n...\ngo(\n  [1, 2, 3, 4, 5],\n  L.map(a =&gt; delay1000(a * a)),\n  L.filter(a =&gt; a % 2),\n  L.map(a =&gt; delay1000(a * a)),\n  reduce((a, b) =&gt; a + b)\n  console.log\n)\n// 707\n// Uncaught (in promise) Symbol(nop)\nPromise.reject의 대한 catch\nPromise.reject의 catch처리는 reduce나 take에서 처리할 것이기 때문에 reject의 catch에 아무것도 하지 않는 function() {} 함수를 할당합니다.\nconst C = {};\nC.reduce = curry((f, acc, iter) =&gt; {\n  const iter2 = iter ? [...iter] : [...acc];\n  iter2.forEach(a =&gt; a.catch(function() {}));\n  // iter2 = iter.map(a =&gt; a.catch(function() {})); 이렇게 처리한다면 추후 catch 불가능!\n  return iter ? reduce(f, acc, iter2) : reduce(f, iter2);\n});\n...\n코드 개선\n아무것도 하지 않는 함수는 자주 사용됨으로 noop이란 이름으로 선언해 두겠습니다. reject을 catch 해주는 부분도 catchNoop이라는 이름으로 선언하여 밖으로 꺼내어 줍니다.\nconst C = {};\nfunction noop() {}\nconst catchNoop = arr =&gt; (\n  arr.forEach(a =&gt; (a instanceof Promise ? a.catch(noop) : a)), arr\n);\nC.reduce = curry((f, acc, iter) =&gt; {\n  const iter2 = catchNoop(iter ? [...iter] : [...acc]);\n  return iter ? reduce(f, acc, iter2) : reduce(f, iter2);\n});\n...\nC.take\nreduce와 같이 결과를 만들어내는 take함수도 병렬적으로 평가할 수 있도록 catchNoop을 이용하여 작성합니다.\n...\nC.take = curry((l, iter) =&gt; take(l, catchNoop([...iter])));\n...\nC.map, C.filter\nC.reduce와 C.take은 전체 작업을 모두 병렬적으로 처리하게 됩니다. 하나의 함수에서만 병렬적으로 처리해야 하는 경우도 있기 때문에 C.map과 C.filter를 작성해 보겠습니다. C.take를 이용한다면 쉽게 작성할 수 있습니다.\n...\nC.takeAll = C.take(Infinity);\n \nC.map = curry(pipe(L.map, C.takeAll));\n \nC.filter = curry(pipe(L.map, C.takeAll));\n참고\n\n함수형 프로그래밍과 JavaScript ES6+\n"},"posts/create-gradle-spring":{"title":"Gradle으로 Spring 프로젝트 생성하기","links":[],"tags":["spring","gradle"],"content":"Gradle 프로젝트\nGradle 설치 후 진행합니다.\nSpring.io 에서 스프링 프레임워크 퀵스타트를 이용하여 Gradle 프로젝트를 다운로드합니다.\nSpring initalizr\nProject → Gradle Project\nLanguage → java\nPackaging → War\nProject Metadata는 자신의 프로젝트에 맞게 수정해서 다운로드합니다.\nbuild.gradle을 수정하여 해당 내용을 추가합니다.\n&lt;!-- build.gradle --&gt;\n\nplugins {\n    id &#039;eclipse-wtp&#039;\n    id &#039;war&#039;\n}\n\ndependencies {\n    providedRuntime &#039;javax.servlet:javax.servlet-api:3.0.1&#039;\n    implementation &#039;jstl:jstl:1.2&#039;\n    implementation &#039;org.reflections:reflections:0.9.9-RC1&#039;\n    implementation &#039;log4j:log4j:1.2.17&#039;\n    implementation &#039;mysql:mysql-connector-java:5.1.30&#039;\n    implementation &#039;org.mybatis:mybatis:3.2.6&#039;\n}\n\nsrc &gt; main에서 webapp 폴더를 추가합니다.\nbuild.gradle가 있는 폴더에서 터미널로 해당 명령어를 실행합니다.\ngradle eclipse\n이클립스에서 Import → Existing Projects into Workspace로 프로젝트를 호출합니다.\n참고\n\nSpring Quickstart Guide\n"},"posts/create-hexo-blog":{"title":"Hexo를 이용하여 깃허브 블로그 만들기","links":[],"tags":["hexo","blog"],"content":"깃허브 블로그 만들기\n개발 공부한 내용들을 정리할 기술 블로그가 필요하게 되었습니다. 편하고 많이들 사용하는 tistory, velog, brunch, notion 등 있지만, Hexo 이용하여 직접 개발 블로그를 작성한 데는 몇 가지 이유가 있습니다.\n장점\n\n커스터마이징의 자유\n\nhexo.io 사이트에서 테마를 골라 빠르게 시작할 수도 있고 직접 만들 수도 있다.\n\n\n게시글 소유권\n\n플랫폼에 종속된 경우 다른 블로그로 이전을 하고 싶어도 이전 게시글들을 이전하기 힘들다.\n\n\n\n단점\n\n손이 많이 간다\n\nA to Z… 처음부터 끝까지 직접 다 만들어야 한다\n\n\n어느 정도의 지식 필요\n\n아무래도 웹으로 개발하고 배포하는 부분에서 개발지식이 필요하다.\n\n\n\n무엇으로 만들지?\nJekyll\n\n특징\n\nRuby 기반\nGitHub Page는 Jekyll에 최적화되어 있음\n\n\n\nHexo\n\n특징\n\nJavascript 기반\n컴파일 속도가 빠름\n\n\n\nHugo\n\n특징\n\nGolang 기반\n컴파일 속도가 빠름\n\n\n\n설치 방법\n기본적으로 node가 설치되어있다는 가정하에 시작하겠습니다.\nnpm i -g hexo-cli\nhexo init\nhexo s\nINFO  Validating config\nINFO  Start processing\nINFO  Hexo is running at &lt;http://localhost:4000&gt; . Press Ctrl+C to stop.\nlocalhost:4000으로 접속하면 기본 Hexo 페이지가 만들어졌습니다. 테마를 적용하도록 해보겠습니다.\nHexo themes\n\n저는 Quiet 테마로 진행해 보겠습니다. 저장소에서 테마를 다운로드 합니다.\ngit clone &lt;github.com/QiaoBug/hexo-theme-quiet.git&gt; ./themes/Quiet\n# config.yml\n \n# Extensions\n## Plugins: &lt;hexo.io/plugins/&gt;\n## Themes: &lt;hexo.io/themes/&gt;\n## theme: landscape\ntheme: Quiet\n_config.yml에서 기존 theme는 주석 처리하고 새로운 테마명으로 변경합니다.\n서버를 종료한 뒤 새로 실행하면 테마가 적용됩니다.\n리포지토리 만들기\n{깃허브ID}.github.io로 리포지토리를 생성한 뒤 푸시합니다.\n\n깃허브 페이지 배포\n깃허브 페이지로 배포를 위하여 새로운 패키지를 다운로드 합니다.\nnpm i hexo-deployer-git\n# config.yml\n \ndeploy:\n  type: git\n  repo: { 리포지토리 주소 }\n  branch: gh-pages\n_config.yml에서 deploy 옵션을 설정합니다.\n배포 명령어를 실행합니다.\nhexo d -g\n깃허브 페이지 설정\n리포지토리 → Setting → GitHub Pages로 이동합니다.\nSource를 gh-pages로 변경한 뒤 {깃허브ID}.github.io로 접속하면 성공적으로 배포된 것을 확인할 수 있습니다.\n참고\n\nHexo Docs\n"},"posts/euclidean":{"title":"유클리드 호제법","links":[],"tags":["algorithm"],"content":"유클리드 호제법이란?\n유클리드 호제법이란 2개의 자연수로 최대공약수를 구하는 알고리즘입니다. 호제법이란 말은 두 수가 서로 상대방의 수를 나누어 결국 원하는 수를 얻는 알고리즘을 말합니다.\n최대공약수\n2개의 자연수 a, b에 대하여 a를 b로 나눈 나머지를 r이라고 하면(단, a &gt; b) a와 b의 최대공약수는 b와 r의 최대공약수와 같습니다. 이 성질에 따라, b를 r로 나눈 나머지 r’를 구하고, 다시 r을 r’로 나눈 나머지를 구하는 과정을 반복하여 나머지가 0이 되었을 때 나누는 수가 a와 b의 최대공약수입니다.\nfunction gcd(min, max) {\n  return min % max ? gcd(max, min % max) : max\n}\n최소공배수\n유클리드 호제법으로 구한 최대공약수를 이용한다면 최소공배수도 쉽게 구할 수 있습니다.\nfunction lcm(min, max) {\n  return (min * max) / gcd(min, max)\n}\n참고\n\n위키백과\n"},"posts/first-class-function":{"title":"일급함수란 무엇인가?","links":[],"tags":["javascript"],"content":"일급함수란?\n함수를 다른 변수와 동일하게 다루는 언어는 일급 함수를 가졌다고 표현합니다. 예를 들어, 일급 함수를 가진 언어에서는 함수를 다른 함수에 매개변수로 제공하거나, 함수가 함수를 반환할 수 있으며, 변수에도 할당할 수 있습니다.\nJavaScript의 일급함수\n함수 할당\n익명 함수를 변수에 할당하여 호출할 수 있습니다. 또한 매개변수의 값이 하나라면 괄호를 생략할 수 있습니다.\nconst add = (a) =&gt; a + 5\nconsole.log(add) // a =&gt; a + 5\nconsole.log(add(5)) // 10\n함수 전달\n함수를 매개변수로 전달하여 호출할 수도 있습니다. 이때 전달하는 함수는 호출하지 않고 함수 자체를 전달하여야 합니다.\nconst sayHello = () =&gt; &quot;Hello&quot;\nconst showHello = (msg, name) =&gt; console.log(`${msg()} ${name}`)\nshowHello(sayHello, &quot;Javascript&quot;) // Hello Javascript\nshowHello(sayHello(), &quot;Javascript&quot;) // Error\n함수 반환\n함수가 함수를 반환하는 형식도 작성이 가능합니다. 이를 자바스크립트에서는 고차 함수라 부릅니다. 또한 고차 함수를 호출 시에는 함수 자체를 반환하기 때문에 다른 변수에 저장하여 호출하거나 이중 괄호를 이용하여 호출합니다.\nconst sayHello = () =&gt; () =&gt; &quot;Hello&quot;\n \nconst myFunc = sayHello()\nmyFunc() // Hello\nsayHello()() // Hello\n참고\n\nMDN Web Docs\n"},"posts/generator-lazy-function":{"title":"제너레이터를 이용하여 함수의 지연평가","links":[],"tags":["javascript","functional-programming"],"content":"지연 평가란?\n컴퓨터 프로그래밍에서 느긋한 계산법(Lazy evaluation)은 계산의 결과 값이 필요할 때까지 계산을 늦추는 기법이다. 위키피디아\n지연 평가를 이용하면, 불필요한 계산을 하지 않게 되어 성능상의 이점이 있으며, 무한의 자료구조를 사용할 수 있습니다. ES6에서 추가된 이터레이터와 제너레이터를 이용하여 지연 평가되는 함수를 작성해 보겠습니다.\n배열을 리턴하는 range함수\n숫자를 받아 숫자만큼의 배열을 리턴하는 함수를 작성해 보겠습니다.\n일반적인 range\nconst range = (l) =&gt; {\n  let i = -1\n  let res = []\n  while (++i &lt; l) {\n    res.push(i)\n  }\n  return res\n}\n \nconst list = range(5) // [0, 1, 2, 3, 4]\nreduce((a, b) =&gt; a + b, list) // 11\n지연 평가를 가지는 L.range\nconst L = {}\nL.range = function* (l) {\n  let i = -1\n  while (++i &lt; l) {\n    yield i\n  }\n}\n \nconst list = L.range(5) // L.range {&lt;suspended&gt;}\nreduce((a, b) =&gt; a + b, list) // 11\n두 가지의 range함수를 작성해 보았습니다. 하나는 배열에 값을 담아 리턴해주는 일반적인 함수이며, 나머지 하나는 제너레이터를 이용한 range함수입니다. 두 함수로 reduce 한 값은 11로 모두 동일하게 보입니다. 하지만 내부적으로 처리되는 방식은 다른데요, 일반적인 range 함수는 호출되는 즉시 배열 값을 리턴 하지만, 제너레이터를 이용한 L.range함수는 이터레이터 값을 리턴합니다.\n입력된 길이 만큼 리턴하는 take\n이번에는 배열의 길이와 배열을 전달하면 입력된 길이만큼 배열을 잘라서 리턴하는 take함수를 작성해보겠습니다.\nconst take = (l, iter) =&gt; {\n  let res = []\n  for (const a of iter) {\n    res.push(a)\n    if (res.length == l) return res\n  }\n  return res\n}\ntake와 range를 이용한 지연 평가\nconsole.log(take(5, range(100))) // [0, 1, 2, 3, 4]\nconsole.log(take(5, L.range(100))) // [0, 1, 2, 3, 4]\ntake 함수를 이용하여 range와 L.range에 적용해 보면 잘 작동하는 것을 확인할 수 있습니다.\n하지만 둘의 내부적으로 작동하는 방식은 다릅니다. range함수는 요청을 받는 즉시 [0, 1, 2, 3…99]의 배열을 완성시켜 take 함수에 전달을 하지만 L.range 즉시 처리하지 않고 이터레이터 값을 전달을 합니다. 그렇게 전달받은 값을 take의 for of에서 하나식 결괏값을 호출하며 진행을 하게 되고, 결과적으로 take의 요청 값인 5번만 range값을 진행하게 됩니다.\n지연 평가를 가지는 L.map, L.filter\n같은 방식으로 이전에 만든 map과 filter 함수도 지연 평가를 가지도록 함수를 재구성해보겠습니다.\nL.map = function* (f, iter) {\n  for (const a of iter) yield f(a)\n}\n \nL.filter = function* (f, iter) {\n  for (const a of iter) if (f(a)) yield a\n}\nL.map과 L.filter는 제너레이터를 이용하여 지연성을 가지며 리턴되는 값은 결괏값이 아닌 이터레이터 값을 반환합니다.\nrange, map, filter, take, reduce 중첩사용\n지금까지 만든 지연 평가되는 함수들을 중첩으로 사용해 보겠습니다.\ngo(\n  range(10),\n  map((n) =&gt; n + 10),\n  filter((n) =&gt; n % 2),\n  take(2),\n)\n \ngo(\n  L.range(10),\n  L.map((n) =&gt; n + 10),\n  L.filter((n) =&gt; n % 2),\n  take(2),\n)\n두 개의 함수의 결괏값은 같지만 진행되는 방식은 다릅니다. 일반적인 range, map, filter 함수는 호출 즉시 값을 만들어 전달을 하지만 지연 평가되는 함수들은 값을 전달하지 않고 호출할 수 있는 이터레이터 값을 전달하며 계산을 미뤄줍니다.\nL.range, L.map, L.filter에서 계산을 진행하지 않고, take 함수까지 도착하게 되면 그제야 계산을 시작하게 됩니다. take 함수에서 for of을 진행할 때 이제 iter에 있는 이터레이터 값을 호출하여 L.filter에서 값을 요청합니다. 그리고 L.filter에서도 이터레이터 값을 호출하여 L.map으로 요청하고 반복해서 L.range까지 요청하게 됩니다. L.range에서 값을 계산한 뒤 다시 map, filter, take 순으로 전달하게 됩니다.\n\n값이 필요할 때에만 이터레이터를 호출하여 값을 계산하기 때문에 take 함수로 인해 값이 2개가 리턴되면 계산이 종료되게 됩니다. 따라서 모든 값을 계산하여 전달하는 일반적인 함수와 다르게 필요한 만큼만 계산해주는 지연 평가는 성능상에 이점이 있습니다.\n참고\n\n함수형 프로그래밍과 JavaScript ES6+\n"},"posts/good-api-uri":{"title":"좋은 API URI 설계하기","links":[],"tags":["http","api"],"content":"개요\n요즘은 웹 애플리케이션 뿐만 아니라 안드로이드나, iOS 애플리케이션 까지 모두 HTTP API 을 이용하여 데이터를 통신합니다. 이렇게 많이 쓰이는 API의 URI를 보다 잘 설계할수 있는 방법을 알아 보겠습니다.\nHTTP API\n회원 정보 관리 API\n\n회원 목록 조회\n\n/read-member-list\n\n\n회원 조회\n\n/read-member-by-id\n\n\n회원 등록\n\n/create-member\n\n\n회원 수정\n\n/update-member\n\n\n회원 삭제\n\n/delete-member\n\n\n\n회원 정보 관리에 대한 API URI를 작성해 보았습니다. 첫 번째에 해당 항목의 작업에 대한 설명을 하고 그 후에 어떠한 작업을 대한 것을 명시하였습니다.\n하지만 이것이 좋은 URI 설계 일까?\nURI(Uniform Resource Identifier)의 R은 리소스를 의미합니다. 그렇다면 리소스란 무엇일까요? 리소스란 조회, 등록, 수정, 삭제 같은 행위가 아닌 회원이란 자체를 의미합니다. 그렇다면 URI에서는 해당 행위들은 모두 배제하여 회원이란 리소스만 식별하여야 합니다.\n회원 정보 관리 API\n\n회원 목록 조회\n\n/members\n\n\n회원 조회\n\n/members/{id}\n\n\n회원 등록\n\n/members/{id}\n\n\n회원 수정\n\n/members/{id}\n\n\n회원 삭제\n\n/members/{id}\n\n\n\n회원이라는 리소스만으로 식별하여 API 작성한다면 다음과 같이 작성이 될 것입니다. 하지만 조회, 등록, 수정, 삭제에 대한 행위들을 어떻게 구별을 할까요?\nHTTP 메서드\n\nGET\n\n리소스 조회\n서버에 전달하고 싶은 데이터는 query를 통해서 전달\n최신 스펙에서는 body를 통해 데이터를 전달할 수 있지만, 지원하지 않는곳이 많아 권장하지 않음\n조회하는 메서드에 사용\n\n\nPOST\n\n요청 데이터 처리\n서버에 전달하고 싶은 데이터는 body를 통해서 전달\n주로 등록하는 메서드에 사용하지만 다른 메서드로 처리하기 애매한 경우 POST로 처리함\n\n\nPUT\n\n리소스 대체\n서버에 전달하고 싶은 데이터는 query와 body를 통해서 전달\n리로스가 있다면 대체하고 없다면 생성(Copy &amp; Paste)\n수정하는 메서드에서 사용되지만 모든 리소스를 대체하기 때문에 사용처가 한정적임\n\n\nPATCH\n\n리소스 부분 변경\n서버에 전달하고 싶은 데이터는 query와 body를 통해서 전달\nPUT과는 다르게 body를 통하여 전달한 데이터만 부분적으로 변경\n수정하는 메서드에 사용\n\n\nDELETE\n\n리소스 삭제\n서버에 전달하고 싶은 데이터는 query를 통해서 전달\n삭제하는 메서드에 사용\n\n\n\nHTTP 메서드를 이용한 API 설계\n회원 정보 관리 API\n\n회원 목록 조회\n\nGET /members\n\n\n회원 조회\n\nGET /members/{id}\n\n\n회원 등록\n\nPOST /members/{id}\n\n\n회원 수정\n\nPATCH /members/{id}\n\n\n회원 삭제\n\nDELETE /members/{id}\n\n\n\n참고\n\n모든 개발자를 위한 HTTP 웹 기본 지식\n"},"posts/http-status-code":{"title":"HTTP의 상태코드의 종류와 의미","links":[],"tags":["http"],"content":"개요\nHTTP 에는 다양한 상태코드가 있습니다. 상태코드별로 어떠한 의미를 가지고 있는지 확인 해보도록 하겠습니다.\nhttp 상태코드\n\n1xx (Informational): 요청이 수신되어 처리중\n2xx (Successful): 요청 정상 처리\n3xx (Redirection): 요청을 완료하려면 추가 행동이 필요\n4xx (Client Error): 클라이언트 오류, 잘못된 문법등으로 서버가 요청을 수행할 수 없음\n5xx (Server Error): 서버 오류, 서버가 정상 요청을 처리하지 못함\n\n1xx (Informational)\n🏃 요청이 수신되어 처리중\n\n거의 사용되지 않음\n\n2xx (Successful)\n🙆 클라이언트의 요청을 성공적으로 처리\n\n200 OK\n\n요청 성공\n주로 리소스를 조회 하는 GET 요청의 응답코드로 사용\n\n\n201 Created\n\n요청 성공하여 새로운 리소스가 생성됨\n주로 리소스를 생성 하는 POST 요청의 응답코드로 사용\n\n\n202 Accepted\n\n요청이 접수되었으나 처리가 완료되지 않음\n배치 처리 같은 곳에서 사용\n\n\n204 No Content\n\n서버가 요청을 성공적으로 수행했지만, 응답 페이로드 본문에 보낼 데이터가 없음\n응답 결과가 필요없는 곳에서 사용\n\n\n\n3xx (Redirection)\n🔨 요청을 완료하기 위해 유저 에이전트의 추가 조치 필요\n\n300 Multiple Choices\n\n거의 사용되지 않음\n\n\n301 Moved Permanently\n\n리소스의 URI가 영구적으로 이동\n원래의 URL를 사용하지 않으며, 검색 엔진에서도 변경을 인지\n리다이렉트시 요청 메서드가 GET으로 변경되고, 본문이 제거될 수 있음\n\n\n302 Found\n\n리소스의 URI가 일시적으로 이동\n리다이렉트시 요청 메서드가 GET으로 변하고, 본문이 제거될 수 있음\n\n\n303 See Other\n\n302 Found와 기능이 같음\n리다이렉트시 요청메서드가 GET으로 반드시 변경됨\n\n\n304 Not Modified\n\n캐시를 목적으로 사용\n클라이언트에게 리소스가 수정되지 않았음을 알려줌\n응답에 메시지 바디를 포함하면 안됨\n주로 GET, HEAD 요청시에 사용\n\n\n307 Temporary Redirect\n\n302 Found와 기능이 같음\n리다이렉트시 요청 메서드와 본문을 유지\n\n\n308 Permanent Redirect\n\n301 Moved Permanently와 기능이 같음\n리다이렉트시 요청 메서드와 본문을 유지\n\n\n일시적인 리다이렉트인 302, 307, 303 중에 무엇을 써야 할까?\n\n초기 302 상태 코드의 스펙 의도는 HTTP의 메서드를 유지하는 것이 였으나, 설명의 모호함으로 인하여 대부분의 브라우저가 GET요청으로 바뀌도록 설계가 되었습니다. 그래서 모호한 302 대신 명확한 307, 303이 등장하였습니다.\n스펙상 307, 303을 권장하지만, 현실적으로 많은 애플리케이션 라이브러리들이 302을 기본값으로 사용하고 있기 때문에 자동 리다이렉션시 GET 요청으로 변경되어도 문제가 없다면 302을 사용하면 됩니다\n\n\n\n4xx (Client Error)\n❗ 클라이언트 오류\n\n400 Bad Request\n\n클라이언트가 잘못된 요청을 해서 서버가 요청을 처리할 수 없음\n\n\n401 Unauthorized\n\n인증(Authentication) 되지 않았거나 인가(Authorization)가 필요함\n\n\n403 Forbidden\n\n서버가 요청을 이해 했지만 승인을 거부함\n인증 자격 증명은 있지만 접근 권한이 불충분한 경우\n\n\n404 Not Found\n\n요청 리소스가 서버에 없음\n클라이언트가 권한이 부족한 리소스에 접근할때 사용하기도 함\n\n\n\n5xx (Server Error)\n⚡ 서버 오류\n\n500 Internal Server Error\n\n서버 내부 문제로 오류 발생\n\n\n503 Service Unavailable\n\n서버가 일시적인 과부하 또는 예정된 작업으로 잠시 요청을 처리할 수 없음\nRetry_after 헤더 필드로 얼마뒤에 복구되는지 보낼 수 있음\n\n\n\n참고\n\n모든 개발자를 위한 HTTP 웹 기본 지식\n"},"posts/index":{"title":"Posts","links":[],"tags":[],"content":""},"posts/iterator-function":{"title":"이터레이터를 이용한 높은 다형성을 가진 함수","links":[],"tags":["javascript","functional-programming"],"content":"다형성(polymorphism)이란?\n프로그램 언어의 다형성은 그 프로그래밍 언어의 자료형 체계의 성질을 나타내는 것으로, 프로그램 언어의 각 요소들(상수, 변수, 식, 오브젝트, 함수, 메서드 등)이 다양한 자료형(type)에 속하는 것이 허가되는 성질을 가리킨다. 반대말은 단형성으로, 프로그램 언어의 각 요소가 한 가지 형태만 가지는 성질을 가리킨다. 위키피디아\n내장함수의 다형성\n다형성이란 하나의 메서드를 여러 개의 객체에 사용할 수 있는 것을 말합니다. javascript의 Array.property인 map을 예로 들어보겠습니다.\nconst arr = [1, 2, 3, 4, 5]\nconsole.log(arr.map((v) =&gt; v)) // [1, 2, 3, 4, 5];\n \nconst dom = document.querySelectorAll(&quot;*&quot;)\nconsole.log(dom.map((el) =&gt; el.nodeName)) // TypeError!\n배열에서는 map 함수가 잘 작동하지만, querySelectorAll로 반환된 배열에는 오류가 발생했습니다. document.querySelectorAll로 반환되는 객체는 배열처럼 보이지만 내부에는 map 함수가 존재하지 않습니다. 따라서 map 함수가 작동되지 않는 것입니다. 그렇기 때문에 유사한 배열의 유형에서도 작동할 수 있는 다형성이 높은 map함수를 직접 구성해보겠습니다.\nconst map = (f, iter) =&gt; {\n  let res = []\n  for (const a of iter) {\n    res.push(f(a))\n  }\n  return res\n}\n \nconst dom = document.querySelectorAll(&quot;*&quot;)\nconsole.log(map((el) =&gt; el.nodeName, dom)) // [&quot;HTML&quot;, &quot;HEAD&quot;, &quot;BODY&quot;]\nmap함수처럼 이터레이터를 이용하여 filter와 reduce도 재작성해보겠습니다.\nconst filter = (f, iter) =&gt; {\n  let res = [];\n  for (const a of iter) {\n    if (f(a)) res.push(a);\n  }\n  return res;\n};\n \nconst reduce = (f, acc, iter) =&gt; {\n  if (!iter) { // iter 입력되지 않은 경우 초기값을 설정합니다.\n    iter = acc[Symbol.iterator](); // Symbol.iterator 호출\n    acc = iter.next().value;\n  }\n  for (const a of iter) {\n    acc = f(acc, a);\n  }\n  return acc;\n여러 메서드를 중첩으로 사용하기\n자바스크립트에서 제공하는 기본 함수처럼 직접 만든 map, filter, reduce 함수도 연속으로 작성할 수 있습니다.\nconst arr = [1, 2, 3, 4, 5]\narr\n  .map((v) =&gt; v)\n  .filter((v) =&gt; v &gt; 3)\n  .reduce((acc, cur) =&gt; acc + cur) // 9\n \nreduce(\n  (acc, cur) =&gt; acc + cur,\n  map(\n    (v) =&gt; v,\n    filter((v) =&gt; v &gt; 3, arr),\n  ),\n) // 9\n위의 코드처럼 작성한다면 직접 작성한 함수들도 중첩하여 사용할 수 있습니다. 하지만 메서드체이닝 기능을 활용한 내장 함수와는 다르게 직접 구현한 함수는 중첩하여 사용하기 때문에 가독성이 떨어지는 문제가 있습니다. 이 부분을 조금 더 보기 좋도록 작성해 보겠습니다.\n함수를 연속으로 실행하는 go함수\n매개변수를 받아 reduce를 실행하는 함수를 작성합니다. go함수는 매개변수를 받아 reduce에게 전달합니다. reduce는 전달받은 매개변수를 가지고 함수를 진행하게 됩니다. 이처럼 다음과 같이 작성한다면 보다 보기 좋은 코드를 작성할 수 있습니다.\nconst go = (...args) =&gt; reduec((a, f) =&gt; f(a), args)\ngo(\n  arr, // reduce의 초기값\n  (arr) =&gt; map((v) =&gt; v, arr), // reduce에서 실행할 함수\n  (arr) =&gt; filter((v) =&gt; v &gt; 3, arr),\n  (arr) =&gt; reduce((acc, cur) =&gt; acc + cur, arr),\n) // 9\n함수를 리턴하는 pipe함수\ngo함수를 이용하여 또 다른 함수를 작성해보겠습니다. pipe함수는 함수를 리턴하는 함수입니다. go를 이용하여 함수를 미리 정의해놓은 상태에서 값만 전달하여 원하는 결과를 얻어낼 수 있습니다.\nconst pipe =\n  (f, ...fs) =&gt;\n  (...as) =&gt;\n    go(f(...as), ...fs)\npipe(\n  (arr) =&gt; map((v) =&gt; v, arr),\n  (arr) =&gt; filter((v) =&gt; v &gt; 3, arr),\n  (arr) =&gt; reduce((acc, cur) =&gt; acc + cur, arr),\n)\npipe(arr)\n함수를 리턴하는 curry함수\n함수를 리턴하는 방식으로 curry함수를 작성해보겠습니다. curry함수는 함수를 리턴하는 함수이며, 매개변수를 하나만 받는다면 또다시 리턴하여 매개변수를 하나 더 받는 함수입니다.\nconst curry =\n  (f) =&gt;\n  (a, ..._) =&gt;\n    _.length ? f(a, ..._) : (..._) =&gt; f(a, ..._)\n \nconst mult = curry((a, b) =&gt; a * b)\nmult(3)(5) // 매개변수를 두번 나누어 요청할 수 있다.\n매개변수의 개수를 체크하여 더 받는다는 것이 왜?라는 의문이 생길 수 있지만, 여기에서 기존에 작성하였던 map, filter, reduce함수에 curry함수를 적용한다면 조금 더 편하게 go함수를 사용할 수 있습니다.\ncurry가 적용된 map, filter, reduce 함수\nconst map = curry((f, iter) =&gt; {\n  let res = []\n  for (const a of iter) {\n    res.push(f(a))\n  }\n  return res\n})\n \nconst filter = curry((f, iter) =&gt; {\n  let res = []\n  for (const a of iter) {\n    if (f(a)) res.push(a)\n  }\n  return res\n})\n \nconst reduce = curry((f, acc, iter) =&gt; {\n  if (!iter) {\n    iter = acc[Symbol.iterator]()\n    acc = iter.next().value\n  }\n  for (const a of iter) {\n    acc = f(acc, a)\n  }\n  return acc\n})\ngo(\n  arr, // 초기값\n  map((v) =&gt; v), // arr =&gt; map(v =&gt; v)(arr)으로 사용할 수 있기 때문에 arr을 생략가능.\n  filter((v) =&gt; v &gt; 3),\n  reduce((acc, cur) =&gt; acc + cur),\n)\n참고\n\n함수형 프로그래밍과 JavaScript ES6+\n"},"posts/iterator-generator":{"title":"이터레이터와 제너레이터","links":[],"tags":["javascript"],"content":"ES6에서 추가된 이터레이터(iterator)와 제너레이터(generator)를 많이 들어 보았는데 어떻게 쓸 수 있는지 알아보도록 하겠습니다.\n이터레이터\n이터러블 객체의 Symbol.iterator 메서드를 호출하면 반환되는 이터레이터는 반복을 위해 설계된 인터페이스 객체이며 {value, done}을 가지며 next의 메서드를 가지고 있습니다.\n순차적 접근\nfor… of은 이터레이터 객체의 done 값이 true가 될 때까지 반복하며 value을 출력해 주는 방식입니다.\nconst arr = [1, 2, 3]\nfor (const a of arr) console.log(a) // 1 2 3\n \n// 인덱스 방식으로 접근하지 않기 때문에 set, map에iter.next(); // 1서도 사용가능\nconst set = new Set([1, 2, 3])\nfor (const a of set) console.log(a) // 1 2 3\n \nconst map = new Map([\n  [&quot;a&quot;, 1],\n  [&quot;b&quot;, 2],\n  [&quot;c&quot;, 3],\n])\nfor (const a of map.keys()) console.log(a) // a b c\nfor (const a of map.values()) console.log(a) // 1 2 3\nfor (const a of map.entries()) console.log(a) // [&#039;a&#039;, 1] [&#039;b&#039;, 2] [&#039;c&#039;, 3]\n메서드 호출\n배열의 인덱스를 순회하는 것이 아닌 이터레이터의 next 메서드를 이용하는 것이기 때문에 이런 식으로도 사용이 가능합니다.\nconst arr = [1, 2, 3]\nconst iter = arr[Symbol.iterator]() // Symbol.iterator을 호출하여 반환된 이터레이터를 할당\niter.next() // {value: 1, done: false};\niter.next() // {value: 2, done: false};\niter.next() // {value: 3, done: false};\niter.next() // {value: undefined, done: true};\niter.next() // {value: undefined, done: true};\niter.next() // {value: undefined, done: true};\n커스텀 이터레이터\n이터레이터만 있다면 for.. of을 사용할 수 있는 특징을 이용하여 임의의 이터레이터를 작성하는 것도 가능합니다.\nconst iterable = {\n  [Symbol.iterator]() {\n    // 호출할수 있는 이터레이터 메서드 작성\n    let i = 3\n    return {\n      next() {\n        // next 메서드 작성\n        return i == 0 ? { vlaue: undefined, done: true } : { value: i--, done: false }\n      },\n      [Symbol.iterator]() {\n        // next 호출 후에도 자기 자신을 반환하도록\n        return this\n      },\n    }\n  },\n}\n \nfor (const a of iterable) console.log(a) // 3 2 1\n제너레이터\n위의 방식으로 커스텀 이터레이터를 만들 수도 있지만 제너레이터를 이용한다면 보다 쉽게 작성할 수 있습니다.\nfunction* iterable(i = 0) {\n  while (true) {\n    yield i++\n    if (i &gt; 100) return undefined\n  }\n}\n \nconst iter = iterable()\niter.next() // {value: 0, done: false};\niter.next() // {value: 1, done: false};\niter.next() // {value: 2, done: false};\n \nconst iter2 = iterable(10) // 제너레이터에 매개변수 전달\niter2.next() // {value: 10, done: false};\niter2.next() // {value: 11, done: false};\niter2.next() // {value: 12, done: false};\n \nfor (const a of iter) {\n  // 이터레이터가 존재하기 때문에 for of 문도 사용이 가능합니다.\n  console.log(a) // 3 4 5 .... 100\n}\n제너레이터는 function* 의 이름으로 함수를 생성하면 됩니다. 그리고 일반 function 이였다면 무한히 돌아가는 while으로 스크립트가 멈추었겠지만, yield라는 키워드로 독특하게 함수가 실행 되게 됩니다.\n제너레이트 함수의 yield는 호출을 할 때마다 해당하는 지점에서 작동을 중지하고 변수를 기억합니다. 또한 return 통해서 종료 시점을 제어할 수도 있습니다.\n참고\n\n함수형 프로그래밍과 JavaScript ES6+\n"},"posts/linux-apache-tomcat":{"title":"Linux Apache2 + Tomcat9 연동 설치","links":[],"tags":["linux","web","was"],"content":"apache2 설치\napache2를 설치합니다.\nsudo apt-get update\nsudo apt-get install apache2\nufw 사용하도록 설정 후 80 포트 추가, 추가된 포트를 확인합니다.\nsudo ufw enable\nsudo ufw allow 80/tcp\nsudo ufw status\n정상적으로 설치되었는지 웹페이지에 localhost &amp; ip를 입력하여 확인합니다.\ntomcat9 설치\ntomcat9를 설치합니다.\nsudo apt-get update\nsudo apt-get install tomcat9\nufw 사용하도록 설정 후 8080 포트 추가, 추가된 포트를 확인합니다.\nsudo ufw enable\nsudo ufw allow 8080/tcp\nsudo ufw status\n\n정상적으로 설치되었는지 웹페이지에 localhost:8080 &amp; ip:8080를 입력하여 확인합니다.\nmod-jk 설치\nmod-jk를 설치합니다.\nsudo apt-get update\nsudo apt-get install libapache2-mod-jk\n세팅\n아래의 파일에서 내용을 수정합니다.\nsudo vi /etc/apache2/workers.properties\n \n# workers.properties\nworkers.tomcat_home=/usr/share/tomcat8\nworkers.java_home=/usr/lib/jvm/default-java\n \n# Define 1 real worker ajp13\nworker.list=tomcat\n \n# Set properties for tomcat1 (ajp13)\nworker.tomcat1.port = 8009\nworker.tomcat1.host = localhost\n \nworker.tomcat1.type = ajp13\nworker.tomcat1.lbfactor = 20\nsudo vi /etc/apache2/mods-available/jk.conf\n \n# JkWorkersFile /etc/libapache2-mod-jk/workers.properties\nJkWorkersFile /etc/apache2/workers.properties\nsudo vi /etc/apache2/sites-available/000-default.conf\n \n#DocumentRoot /var/www/html\nDocumentRoot /var/lib/tomcat9/webapps/ROOT\nJkMount /* tomcat\nsudo vi /etc/tomcat9/server.xml\n \n&lt;!--\n&lt;Connector port=&quot;8009&quot; protocol=&quot;AJP/1.3&quot; redirectPort=&quot;8443&quot; /&gt;\n--&gt;\napache2와 tomcat9을 재시작 합니다.\nservice apache2 restart\nservice tomcat9 restart\n정상적으로 설치되었는지 웹페이지에 localhost &amp; ip를 입력하여 확인합니다. 톰캣의 페이지가 나온다면 정상적으로 설정되었습니다."},"posts/linux-mssql2019-install":{"title":"Linux MSSQL 2019 설치","links":[],"tags":["linux","database"],"content":"MSSQL 설치\nMSSQL은 메모리가 최소 2G가 넘어야 설치할 수 있습니다.\n공용 리포지토리 GPG 키를 가져옵니다.\nwget -qO- &lt;packages.microsoft.com/keys/microsoft.asc&gt; | sudo apt-key add -\nMicrosoft SQL Server Ubuntu 리포지토리를 등록합니다.\nsudo add-apt-repository &quot;$(wget -qO- &lt;packages.microsoft.com/config/ubuntu/18.04/mssql-server-2019.list&gt;)&quot;\napt-get을 업데이트한 후 SQL Server를 설치합니다.\nsudo apt-get update\nsudo apt-get install -y mssql-server\nmssql-conf setup을 실행합니다.\nsudo /opt/mssql/bin/mssql-conf setup\n\nEnter your edition(1-8)\n: 특별히 라이선스가 있는 것이 아니라면 2.Developer / 3.Express 둘 중에 하나를 선택하면 됩니다.\nDo you accept the license terms?\n: 라이선스 조건에 동의합니다. (Yes)\nEnter the SQL Server system administrator password:\n: SA 계정의 패스워드를 설정합니다. 대문자 및 소문자, 기본 10자리 숫자 및/또는 영숫자가 아닌 기호를 포함하여 최소 길이 8자.\n\nmssql 서비스가 실행 중인지 확인합니다.\nsystemctl status mssql-server --no-pager\n \n● mssql-server.service - Microsoft SQL Server Database Engine\n   Loaded: loaded (/lib/systemd/system/mssql-server.service; enabled; vendor preset: enabled)\n   Active: active (running) since Wed 2021-05-19 07:20:39 UTC; 1min 52s ago\n     Docs: &lt;docs.microsoft.com/en-us/sql/linux&gt;\n Main PID: 22746 (sqlservr)\n    Tasks: 118\n   CGroup: /system.slice/mssql-server.service\n           ├─22746 /opt/mssql/bin/sqlservr\n           └─22779 /opt/mssql/bin/sqlservr\nSQL Server 명령줄 도구 설치\n공용 리포지토리 GPG 키를 가져옵니다.\ncurl &lt;packages.microsoft.com/keys/microsoft.asc&gt; | sudo apt-key add -\nMicrosoft Ubuntu 리포지토리를 등록합니다.\ncurl &lt;packages.microsoft.com/config/ubuntu/18.04/prod.list&gt; | sudo tee /etc/apt/sources.list.d/msprod.list\nMSSQL-Tools 설치 합니다.\nsudo apt-get update\nsudo apt-get install mssql-tools\n커맨드 입력 시 실행이 되도록 환경변수에 등록합니다.\necho &#039;export PATH=&quot;$PATH:/opt/mssql-tools/bin&quot;&#039; &gt;&gt; ~/.bashrc\nsource ~/.bashrc\nsqlcmd -S localhost -U SA\n1&gt;\n방화벽 설정\nufw 사용하도록 설정 후 1433 포트 추가, 추가된 포트를 확인합니다.\nsudo ufw enable\nsudo ufw allow 3306/tcp\nsudo ufw status\n \nStatus: active\n \nTo                         Action      From\n--                         ------      ----\n1433/tcp                   ALLOW       Anywhere\n1433/tcp (v6)              ALLOW       Anywhere (v6)\nyougetsignal에서 포트가 정상적으로 열렸는지 확인합니다.\n참고\n\nMicrosoft Docs\n"},"posts/linux-mysql57-install":{"title":"Linux MySQL 5.7 설치","links":[],"tags":["linux","database"],"content":"MySQL 설치\napt-get을 업데이트한 후 MySQL을 설치합니다.\nsudo apt-get update\nsudo apt-get install mysql-server\n부팅 시 MySQL이 시작되도록 설정합니다.\nsudo systemctl enable mysql\n기본 보안 세팅합니다.\nsudo mysql_secure_installation\n\nVALIDATE PASSWORD plugin?\n: 테스트 환경이라 활성화하지 않았습니다. (n)\nNew password:\n: 초기 비밀번호를 설정해줍니다.\nRemove anonymous users?\n: 익명의 사용자를 삭제합니다. (y)\nDisallow root login remotely?\n: 외부에서 root 계정으로 접속하지 못하게 합니다. (y)\nRemove test database and access to it?\n: test DB를 삭제합니다. (y)\nReload privilege tables now?\n: privilege tables 을 reload 해줍니다. (y)\n\n외부접속 설정\n네트워크 상태 확인합니다.\nnetstat -tnl\n \nActive Internet connections (only servers)\nProto Recv-Q Send-Q Local Address           Foreign Address         State\ntcp        0      0 127.0.0.1:3306          0.0.0.0:*               LISTEN\n127.0.0.1:3306으로 설정되어 있습니다. 외부에서 접속할 수 있도록 로컬 어드레스를 수정합니다.\nvi /etc/mysql/mysql.conf.d/mysqld.cnf\n...\nbind-address = 0.0.0.0\nMySQL을 재시작합니다.\nservice mysql restart\n다시 네트워크 상태를 확인합니다.\nnetstat -tnl\n \nActive Internet connections (only servers)\nProto Recv-Q Send-Q Local Address           Foreign Address         State\ntcp        0      0 0.0.0.0:3306            0.0.0.0:*               LISTEN\n0.0.0.0:3306으로 변경이 완료 되었습니다.\n외부 접속 계정 설정\nMySQL root 계정으로 접속해서 외부에서 접속할 계정 생성 및 데이터베이스에 권한을 할당합니다.\n*.* 부분을 데이터베이스·테이블로 입력 시 해당 데이터베이스만 접속할 수 있도록 설정할 수 있습니다.\nmysql -u root -p\n \nmysql&gt; GRANT ALL privileges on *.* to &#039;계정&#039;@&#039;%&#039; identified by &#039;암호&#039;;\nmysql&gt; Flush privileges;\nmysql&gt; SELECT host,user FROM mysql.user;\n+-----------+------------------+\n| host      | user             |\n+-----------+------------------+\n| %         | user             |\n| localhost | debian-sys-maint |\n| localhost | mysql.session    |\n| localhost | mysql.sys        |\n| localhost | root             |\n+-----------+------------------+\n5 rows in set (0.00 sec)\n방화벽 설정\nufw 사용하여 외부에서 접속을 할 수 있도록 설정 합니다.\nsudo ufw enable\nsudo ufw allow 3306/tcp\nsudo ufw status\n \nStatus: active\n \nTo                         Action      From\n--                         ------      ----\n3306/tcp                   ALLOW       Anywhere\n3306/tcp (v6)              ALLOW       Anywhere (v6)\nyougetsignal에서 포트가 정상적으로 열렸는지 확인합니다."},"posts/mac-hammerspoon":{"title":"macOS 한영 전환 단축키 변경하기 (M1)","links":[],"tags":["mac"],"content":"개요\nM1 Mac에서 한영전환키는 Capslock키 입니다. Capslock키는 대소문자와 한영전환을 모두 수행하는 키라서 전환에 딜레이가 발생해서 매끄럽게 작동하지 않습니다. 그렇기 때문에 키를 변경 해 보도록 하겠습니다.\nHammerSpoon?\nMac에서의 키매핑하는 방법은 여러가지가 있습니다.\ncom.apple.symbolichotkeys.plist을 수정하여 변경하는 방법이나 유명한 karabiner같은 앱을 사용하여 변경을 할 수도 있습니다. com.apple.symbolichotkeys.plist을 수정하여 변경하는 방법은 간편하지 않고, karabiner으로 변경하는 것은 m1에서 문제가 있어서 이번에는 hammerspoon을 이용하여 변경해 보겠습니다.\n설치\nbrew를 이용하여 hammerspoon을 설치합니다.\nbrew install hammerspoon\nfinder에서 shift + command + g 을 눌러 ~/.hammerspoon 을 입력하여 경로로 이동합니다.\nmodules 폴더를 생성하여 아래의 파일들을 저장합니다.\nfoundation_remapping.lua\ninputsource_aurora.lua\nhammerspoon에서 Open Config을 합니다. init.lua에 아래의 내용을 입력합니다.\nrequire(&#039;modules.inputsource_aurora&#039;)\nlocal FRemap = require(&#039;modules.foundation_remapping&#039;)\nlocal remapper = FRemap.new()\nremapper:remap(&#039;rcmd&#039;, &#039;f18&#039;)\nremapper:register()\n전 오른쪽 커맨드키를 리매핑 해주었습니다.\n시스템환경설정 → 키보드 → 단축키로 이동해 입력 메뉴에서 다음 소스 선택을 리매핑해준 키로 변경합니다.\n\n입력메뉴가 변경되면 아래처럼 변경된 입력메뉴가 표시 됩니다.\n\n참고\n\n김정환블로그\nfoundation_remapping\n"},"posts/mysql-utf8":{"title":"MySQL에서 한글 깨짐","links":[],"tags":["spring","gradle"],"content":"원인\ncharacterset UTF-8로 되어있지 않아서 발생하는 문제입니다.\n데이터베이스 생성 시 기본적으로 utf-8 형식으로 만들어지도록 수정해 보겠습니다.\nmysqld.cnf 수정합니다.\nvi /etc/mysql/mysql.conf.d/mysqld.cnf\n \n[client]\ndefault-character-set   = utf8\n[mysqld]\ncharacter-set-server    = utf8\ncollation-server        = utf8_general_ci\n \nmysql&gt; status\n \nServer characterset:\tutf8\nDb     characterset:\tutf8\nClient characterset:\tutf8\nConn.  characterset:\tutf8"},"posts/nodemon-config":{"title":"Nodemon 모니터링 파일 설정하기","links":[],"tags":["node"],"content":"개요\n테스트 환경에서 사용하는 Nodemon을 사용하다 보면 모니터링하는 파일을 직접 설정할 필요가 있습니다. 그럴 경우 설정 파일을 작성하면 해당 파일이 변경될 때만 감사하도록 설정할 수 있습니다.\n설정\n// nodemon.json\n{\n  &quot;ext&quot;: &quot;.js, .json&quot;\n}\n참고\n\nNPM - nodemon\n"},"posts/react-type":{"title":"React의 종류","links":[],"tags":["react"],"content":"Function? Class?\n리액트는 함수형 컴포넌트(Functional Component)와 클래스형 컴포넌트(Class Component)로 나누어집니다. 함수형 컴포넌트로 작성 시에 코드가 매우 짧아지게 되는데, 알아보도록 하겠습니다.\n클래스형 컴포넌트\n\nstate기능 및 라이프사이클 기능을 사용할 수 있고 임의 메서드를 정의할 수 있다.\nrender 함수가 꼭 있어야 하고, 그 안에서 보여 주어야 할 jsx를 반환해야 한다\n\nimport React from &quot;react&quot;\n \nclass App extends React.Component {\n  constructor(props) {\n    super(props)\n    this.state = {\n      first: Math.ceil(Math.random() * 9),\n      second: Math.ceil(Math.random() * 9),\n      value: &quot;&quot;,\n      result: &quot;&quot;,\n    }\n  }\n \n  onSubmit = () =&gt; {\n    e.preventDefault()\n    if (parseInt(this.state.value) === this.state.first * this.state.second) {\n      this.setState((prevState) =&gt; {\n        return {\n          result: `정답: ${prevState.value}`,\n          first: Math.ceil(Math.random() * 9),\n          second: Math.ceil(Math.random() * 9),\n          value: &quot;&quot;,\n        }\n      })\n    } else {\n      this.setState({\n        result: &quot;땡&quot;,\n        value: &quot;&quot;,\n      })\n    }\n    this.input.focus()\n  }\n \n  onChange = (e) =&gt; this.setState({ value: e.target.value })\n \n  render() {\n    return (\n      &lt;React.Fragment&gt;\n        &lt;div&gt;\n          {this.state.first} 곱하기 {this.state.second}는?\n        &lt;/div&gt;\n        &lt;form onSubmit={this.onSubmit}&gt;\n          &lt;input\n            ref={(c) =&gt; {\n              this.input = c\n            }}\n            type=&quot;number&quot;\n            value={this.state.value}\n            onChange={this.onChange}\n          /&gt;\n          &lt;button&gt;입력!&lt;/button&gt;\n          &lt;div&gt;{this.state.result}&lt;/div&gt;\n        &lt;/form&gt;\n      &lt;/React.Fragment&gt;\n    )\n  }\n}\n함수형 컴포넌트\n\n선언하기가 간편하다.\n메모리가 클래스형 컴포넌트보다 덜 사용한다.\n\nimport React,{useState, useRef} from &#039;react&#039;;\n \nclass App extends React.Component {\n  const [first, setFirst] = useState(Math.ceil(Math.random() * 9));\n  const [second, setSecond] = useState(Math.ceil(Math.random() * 9));\n  const [value, setValue] = useState(&#039;&#039;);\n  const [result, setResult] = useState(&#039;&#039;);\n  const inputEl = useRef(null);\n \n  const onSubmitForm = (e) =&gt; {\n    e.preventDefault();\n    if (parseInt(value) === first * second) {\n      setResult(&#039;정답&#039;);\n      setFirst(Math.ceil(Math.random() * 9));\n      setSecond(Math.ceil(Math.random() * 9));\n      setValue(&#039;&#039;);\n      inputEl.current.focus();\n    } else {\n      setResult(&#039;땡&#039;);\n      setValue(&#039;&#039;);\n      inputEl.current.focus();\n    }\n  };\n  return (\n    &lt;&gt;\n      &lt;div&gt;{first} 곱하기 {second}는?&lt;/div&gt;\n      &lt;form onSubmit={onSubmitForm}&gt;\n        &lt;input\n          ref={inputEl}\n          type=&quot;number&quot;\n          value={value}\n          onChange={(e) =&gt; setValue(e.target.value)}\n        /&gt;\n        &lt;button&gt;입력!&lt;/button&gt;\n      &lt;/form&gt;\n      &lt;div id=&quot;result&quot;&gt;{result}&lt;/div&gt;\n    &lt;/&gt;\n  );\n}\n다음과 같이, 같은 코드를 작성하더라도 함수형 컴포넌트로 작성 시에 코드량이 매우 줄어드는 것을 알 수 있습니다. 그리고 React의 공식문서에서도 가능하다면 함수형 컴포넌트와 Hook을 사용하기를 권장하고 있으니, 특별한 이유가 있지 않다면 함수형 컴포넌트로 작성하시면 되겠습니다.\n참고\n\n웹 게임을 만들며 배우는 React\n"},"posts/spring-json":{"title":"Spring에서 JSON사용하기","links":[],"tags":["spring","jquery"],"content":"원인\n스프링 프레임워크를 사용 시에 json 객채의 경우에는 string 타입으로 변환되어 전달이 되지만 배열 객체의 경우 전달이 되지 않습니다. http 통신은 원래 문자열만 전송할 수 있기 때문에 객체의 배열의 경우 직렬화를 하여 문자열 형태로 보내주어야 합니다.\n해결 방법\najax\njquery을 이용하여 ajax로 객채 배열을 직렬화 시켜 String 타입으로 서버 측으로 전송합니다.\nlet person = [\n  { name: &quot;James&quot;, age: 25, skill: &quot;HTML&quot; },\n  { name: &quot;John&quot;, age: 22, skill: &quot;CSS&quot; },\n  { name: &quot;Robert&quot;, age: 21, skill: &quot;JavaScript&quot; },\n]\nlet jsonData = JSON.stringify(person) // JSON 타입으로 데이터 직렬화\n//&quot;[{\\\\&quot;name\\\\&quot;:\\\\&quot;James\\\\&quot;,\\\\&quot;age\\\\&quot;:25,\\\\&quot;skill\\\\&quot;:\\\\&quot;HTML\\\\&quot;}, ...]&quot;\n \n$.ajax({\n  url: &quot;getJson.do&quot;,\n  type: &quot;POST&quot;,\n  data: { jsonData: jsonData },\n  dataType: &quot;json&quot;,\n  success: function () {\n    //\n  },\n  error: function () {\n    //\n  },\n})\nspring\n전달된 String 타입의 문자열을 JSON 라이브러리를 이용하여 다시 JSON 타입으로 변환시켜 객체에 다시 세팅합니다.\nimport net.sf.json.JSONArray;\nimport net.sf.json.JSONObject;\n \n@RequestMapping(value = &quot;/getJson.do&quot;, method = RequestMethod.POST)\npublic Object getJson(@RequestParam String jsonData) throws Exception {\n  // 직렬화 시켜 가져온 오브젝트 배열을 JSONArray 형식으로 바꿔준다.\n  JSONArray array = JSONArray.fromObject(jsonData);\n \n  List&lt;Person&gt; persons = new ArrayList&lt;Person&gt;();\n  for (int i = 0; i &lt; array.size(); i++) {\n    // JSONArray 형태의 값을 가져와 JSONObject 로 풀어준다.\n    JSONObject obj = (JSONObject) array.get(i);\n \n    Person person = new Person();\n    person.setName((int) obj.get(&quot;name&quot;));\n    person.setAge((int) obj.get(&quot;age&quot;));\n    person.setSkill((String) obj.get(&quot;skill&quot;));\n    persons.add(person);\n  }\n}\ngradle\ndependencies {\n  implementation &#039;net.sf.json-lib:json-lib:2.4:jdk15&#039;\n}\n"},"posts/tomcat-utf8":{"title":"Windows Tomcat 배치파일 한글 깨짐","links":[],"tags":["windows","tomcat"],"content":"원인\nWindows 환경에서 톰캣 배치파일 실행 시에 한글이 깨지는 이유는 톰캣 콘솔 코드 페이지가 ANSI/OEM으로 설정되어 있어서 한글이 깨져서 출력됩니다.\n해결 방법\nCMD에서 해당 명령어를 입력하면 콘솔 페이지가 UTF-8 형식으로 변경됩니다.\nREG ADD HKCU\\\\Console\\\\Tomcat /v CodePage /t REG_DWORD /d 65001\n참고\n\n톰캣(Tomcat) cmd 실행시 한글 깨짐 현상 해결\n"},"posts/transpose":{"title":"이차원 배열 행과 열 바꾸기","links":[],"tags":["algorithm"],"content":"Python zip\n파이썬의 내장 함수 중 zip을 이용한다면 행열을 쉽게 바꾸어 줄 수 있습니다. 이러한 방식을 자바스크립트에서도 사용해 보겠습니다.\nconst zip = (r) =&gt; r[0].map((_, c) =&gt; r.map((r) =&gt; r[c]))\n참고\n\n[javascript] Python의 zip 함수와 동등한 Javascript\n"},"posts/vscode-vim":{"title":"VSCode에서 vim 설치 및 IM 세팅하기","links":[],"tags":["vscode","vim"],"content":"vim이란?\nVim은 유닉스 환경에서 사용되는 텍스트 편집기 중에 하나인 vi에 독자적으로 다양한 기능들을 추가해 편의를 돕고 있는 편집기입니다. Vim의 설명은 다른 곳에서도 많이 설명이 되어있으니 바로 VSCODE에 Vim을 적용해 보겠습니다.\n설치\nVSCode\nVS Code의 익스텐션에서 vim을 검색하여 설치해 줍니다.\nVS Code에서 해당 익스텐션을 설치 후 사용하다 보면 불편함점이 발생하게 되는데요, vim의 명령어들은 모두 영어로 작성되어있어서 코드를 작성하며 한글로 주석을 입력한 뒤 입력 모드에서 빠져나오게 되면 명령 모드에서도 한글로 되어있어 명령이 입력되지 않습니다. 매번 한글을 바꿔주기보다는 명령 모드로 진입 시에는 자동으로 영어로 변경되도록 설정해 보겠습니다.\nim-select(MAC)\n입력기를 제어할 수 있는 im-select를 설치해 줍니다.\ncurl -Ls &lt;raw.githubusercontent.com/daipeihust/im-select/master/install_mac.sh&gt; | sh\n...\nim-select\ncom.apple.keylayout.ABC\nim-select라는 프로그램은 입력방식을 제어하는 프로그램으로서 im-select을 입력한다면 현재의 입력방식을 확인할 수 있으며, im-select com.apple.keylayout.ABC으로 입력하면 현재 입력방식을 영문으로 변경해 줍니다. 이 부분을 이용하여 vim 확장 프로그램에서 설정을 하도록 하겠습니다.\nVSCODE의 설정에서 json 편집으로 진입합니다.\n  ...\n  &quot;vim.autoSwitchInputMethod.enable&quot;: true\n  &quot;vim.autoSwitchInputMethod.defaultIM&quot;: &quot;com.apple.keylayout.ABC&quot;,\n  &quot;vim.autoSwitchInputMethod.obtainIMCmd&quot;: &quot;/usr/local/bin/im-select&quot;,\n  &quot;vim.autoSwitchInputMethod.switchIMCmd&quot;: &quot;/usr/local/bin/im-select {im}&quot;,\n설정의 맨 마지막 줄에 해당 내용들을 추가해 줍니다.\n\nenable: autoSwitchInputMethod 기능을 활성화합니다.\ndefaultIM: 명령 모드에서 기본적으로 설정될 입력방식을 지정합니다.\nobtainIMCmd: 현재의 입력 모드를 확인할 수 있는 명령어를 지정합니다.\nswitchIMCmd: 입력 모드를 변경할 수 있는 명령어를 지정합니다. {im}은 defaultIM에서 참조하여 변경됩니다.\n\n다음과 같이 변경을 하게 된다면, 입력 모드에서 명령 모드로 변경 시 기존의 IM을 기억하기 때문에 입력 모드(한글) → 명령 모드(영문) → 입력 모드(한글)의 방식도 잘 지원을 하게 됩니다.\n참고\n\nVisual Studio Marketplace\n"}}